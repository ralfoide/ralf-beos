/*  A program to test and time real input fast fourier transform routine	*/#include <stdio.h>#include <stdlib.h>#include <math.h>#include "fftlib.h"#define	MACTIMING 1		/* true means time fft with macintosh calls	*/#if MACTIMING#include <timer.h>#endif#define	NUMROWS 1		/* process Matrix of NUMROWS different ffts of length N	*/#define N 2048			/* size of FFT, must be a power of 2 */#define NTIMES 20		/* number of timing loops, invalid if too big (if a[0][0] == 0 | nan)*/void main(){float		*Utbl;float		(*a)[N];#if MACTIMINGUnsignedWide 		TheTime1;UnsignedWide 		TheTime2;UnsignedWide 		TheTime3;double		TheTime;#endiflong 		i, il;long 		TheErr;long		M;Utbl = (float *) malloc((N/4+1)*sizeof(float));if (Utbl==0)	TheErr = 2;elseTheErr = rFFTInit(&M, N, Utbl);if(!TheErr){	a = (float (*)[N]) malloc(NUMROWS*N*sizeof(float));	if (a == 0) TheErr = 2;}if(!TheErr){			/*  set up a simple test case */	for (il=0; il<NUMROWS; il++){		for (i=0; i<N; i+=2){			a[il][i] = sqrt(il+i+.77777);				a[il][i+1] = (il+i+.22222)*(il+i+.22222) / N - N/2;			}		a[il][0] = N+3;		a[il][2] = 1-N;	}#if MACTIMING	Microseconds(&TheTime1);	for (i=0;i<NTIMES;i++){		/* do many times for timing */		rffts((float *)a, M, NUMROWS, Utbl);	}	Microseconds(&TheTime2);	for (i=0;i<NTIMES;i++){		/* do many times for timing */		riffts((float *)a, M, NUMROWS, Utbl);	}	Microseconds(&TheTime3);	TheTime = (double)(TheTime2.hi - TheTime1.hi) * 65536.0 * 65536.0;	TheTime = (TheTime + (double)(TheTime2.lo - TheTime1.lo))/1000.0;	printf("Time rfft = %12f   ms.    a[0][0]= %6e\n", TheTime/NTIMES/NUMROWS, a[0][0]);	TheTime = (double)(TheTime3.hi - TheTime2.hi) * 65536.0 * 65536.0;	TheTime = (TheTime + (double)(TheTime3.lo - TheTime2.lo))/1000.0;	printf(" rifft = %12f  ms. a[0][0].Re= %6e\n", TheTime/NTIMES/NUMROWS, a[0][0]);#else	printf("start timing \n");	for (i=0;i<NTIMES;i++){		/* do many times for timing */		rffts((float *)a, M, NUMROWS, Utbl);		riffts((float *)a, M, NUMROWS, Utbl);	}	printf("end timing \n");#endif	printf("\n");			/*  set up a simple test case */	for (il=0; il<NUMROWS; il++){		for (i=0; i<N; i+=2){			a[il][i] = sqrt(il+i+.77777);				a[il][i+1] = (il+i+.22222)*(il+i+.22222) / N - N/2;			}		a[il][0] = N+3;		a[il][2] = 1-N;	}	rffts((float *)a, M, NUMROWS, Utbl);	if (N*NUMROWS <= 512){ 		for (il=0; il<NUMROWS; il++){			printf("atrans = [ \n");			for (i=0; i<N; i+=2)				printf(" %+20.15e + j * ( %+20.15e ) \n", a[il][i], a[il][i+1]);			printf("]; \n");				}		}	else {  /* abbreviate big output */		printf("the last 20 values of the first real fft are: \n");		for (i=N-40; i<N; i+=2)			printf(" %+20.15e + j * ( %+20.15e ) \n", a[0][i], a[0][i+1]);	}	riffts((float *)a, M, NUMROWS, Utbl);	if (N*NUMROWS <= 512){ 		for (il=0; il<NUMROWS; il++){			printf("aitrans = [ \n");			for (i=0; i<N; i+=2)				printf(" %+20.15e ; %+20.15e \n", a[il][i], a[il][i+1]);			printf("]; \n");				}		}	else {  /* abbreviate big output */		printf("the last 40 values of the first real ifft are: \n");		for (i=N-40; i<N; i+=1)				printf(" %+20.15e \n", a[0][i]);	}	free (a);	free (Utbl);}elseif(TheErr==2)	printf(" out of memory ");else	printf(" error ");return;}