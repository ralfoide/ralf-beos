
Function: ??0CMoteurRecord@@QAE@IAAVRPath@@@Z
/*****************************************************************************

	Projet	: VideoShooter

	Fichier	:	CMoteurRecord.cpp
	Partie	: Moteur

	Auteur	: RM
	Date		: 190798
	Format	: tabs==2

*****************************************************************************/

#include "CMoteurRecord.h"
#include "externs.h"
#include "gMacros.h"
#include "gErrors.h"


//---------------------------------------------------------------------------

ui32 _gDiffRec=0;
ui32 _gConstRec=0;



//***************************************************************************
CMoteurRecord::CMoteurRecord(RPath &path)
							:RThread(),
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 83 EC 78    SUB     ESP, 00000078
00008: 0009 89 CB       MOV     EBX, ECX
00009: 000B 8B 45 08    MOV     EAX, DWORD PTR 00000008[EBP]
00010: 000E 25 00000001 AND     EAX, 00000001
00011: 0013 09 C0       OR      EAX, EAX
00012: 0015 74 20       JE      L0001
00013: 0017             NOOP    
00014: 0017 8D 83 00000134LEA   EAX, DWORD PTR 00000134[EBX]
00015: 001D 89 43 04    MOV     DWORD PTR 00000004[EBX], EAX
00016: 0020 8B 43 04    MOV     EAX, DWORD PTR 00000004[EBX]
00017: 0023 89 43 44    MOV     DWORD PTR 00000044[EBX], EAX
00018: 0026 B8 00000008 MOV     EAX, OFFSET ??_7RInterface@@6B@+00000008
00019: 002B 89 83 00000134MOV   DWORD PTR 00000134[EBX], EAX
00020: 0031             NOOP    
00021: 0031 8D 83 00000134LEA   EAX, DWORD PTR 00000134[EBX]
00022: 0037     L0001
00023: 0037 6A 00       PUSH    00000000
00024: 0039 89 D9       MOV     ECX, EBX
00025: 003B E8 00000000 CALL    NEAR PTR ??0RThread@@QAE@I@Z
00026: 0040                    
00027: 0040 83 C4 04    ADD     ESP, 00000004
00028: 0043             NOOP    
00029: 0043 8D 53 40    LEA     EDX, DWORD PTR 00000040[EBX]
00030: 0046             NOOP    
00031: 0046 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7CMoteurDocument@@6B@+00000008
00032: 004C 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00033: 004F C7 00 00000014 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7CMoteurDocument@@6B@+00000014
00034: 0055 C7 42 08 00000000 MOV DWORD PTR 00000008[EDX], 00000000
00035: 005C C7 42 0C 00000000 MOV DWORD PTR 0000000C[EDX], 00000000
00036: 0063 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7CMoteurRecord@@6B@+00000008
00037: 0069 8B 43 04    MOV     EAX, DWORD PTR 00000004[EBX]
00038: 006C C7 00 00000024 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7CMoteurRecord@@6B@+00000024
00039: 0072 C7 43 40 00000018 MOV DWORD PTR 00000040[EBX], OFFSET ??_7CMoteurRecord@@6B@+00000018
00040: 0079             NOOP    
00041: 0079 8D 73 60    LEA     ESI, DWORD PTR 00000060[EBX]
00042: 007C             NOOP    
00043: 007C BF 00000008 MOV     EDI, OFFSET ??_7RInterface@@6B@+00000008
00044: 0081 89 3E       MOV     DWORD PTR 00000000[ESI], EDI
00045: 0083 C7 06 00000008 MOV  DWORD PTR 00000000[ESI], OFFSET ??_7?$TRotateBuffer@PAVRBitmap@@@@6B@+00000008
00046: 0089             NOOP    
00047: 0089 8D 46 08    LEA     EAX, DWORD PTR 00000008[ESI]
00048: 008C             NOOP    
00049: 008C 89 38       MOV     DWORD PTR 00000000[EAX], EDI
00050: 008E C7 00 00000008 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@6B@+00000008
00051: 0094 C7 40 04 00000008 MOV DWORD PTR 00000004[EAX], 00000008
00052: 009B C7 40 10 00000000 MOV DWORD PTR 00000010[EAX], 00000000
00053: 00A2 C7 40 08 00000000 MOV DWORD PTR 00000008[EAX], 00000000
00054: 00A9 C7 40 0C 00000000 MOV DWORD PTR 0000000C[EAX], 00000000
00057: 00B0 8D 46 24    LEA     EAX, DWORD PTR 00000024[ESI]
00055: 00B3 6A 01       PUSH    00000001
00056: 00B5             NOOP    
00058: 00B5 89 C1       MOV     ECX, EAX
00059: 00B7 E8 00000000 CALL    NEAR PTR ??0RSem@@QAE@I@Z
00060: 00BC                    
00061: 00BC 83 C4 04    ADD     ESP, 00000004
00062: 00BF C7 46 04 00000000 MOV DWORD PTR 00000004[ESI], 00000000
00063: 00C6 C7 46 20 00000000 MOV DWORD PTR 00000020[ESI], 00000000
00064: 00CD 8B 46 20    MOV     EAX, DWORD PTR 00000020[ESI]
00067: 00D0 89 F1       MOV     ECX, ESI
00065: 00D2 89 46 1C    MOV     DWORD PTR 0000001C[ESI], EAX
00066: 00D5 6A 03       PUSH    00000003
00068: 00D7 E8 00000000 CALL    NEAR PTR ?init@?$TRotateBuffer@PAVRBitmap@@@@IAEXJ@Z
00069: 00DC                    
00070: 00DC 83 C4 04    ADD     ESP, 00000004
00071: 00DF 89 5D 80    MOV     DWORD PTR FFFFFF80[EBP], EBX
00072: 00E2 81 45 80 000000B0 ADD DWORD PTR FFFFFF80[EBP], 000000B0
00073: 00E9             NOOP    
00074: 00E9 8B 55 80    MOV     EDX, DWORD PTR FFFFFF80[EBP]
00076: 00EC 8B 45 80    MOV     EAX, DWORD PTR FFFFFF80[EBP]
00075: 00EF 83 C2 20    ADD     EDX, 00000020
00077: 00F2 89 50 1C    MOV     DWORD PTR 0000001C[EAX], EDX
00078: 00F5 89 78 20    MOV     DWORD PTR 00000020[EAX], EDI
00079: 00F8 05 00000020 ADD     EAX, 00000020
00082: 00FD 8B 4D 80    MOV     ECX, DWORD PTR FFFFFF80[EBP]
00080: 0100 8B 45 0C    MOV     EAX, DWORD PTR 0000000C[EBP]
00081: 0103 50          PUSH    EAX
00083: 0104 FF 15 00000000 CALL DWORD PTR __imp_??0BPath@@QAE@ABV0@@Z
00084: 010A                    
00085: 010A 83 C4 04    ADD     ESP, 00000004
00086: 010D 8B 45 80    MOV     EAX, DWORD PTR FFFFFF80[EBP]
00087: 0110 C7 00 00000008 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7RPath@@6B@+00000008
00088: 0116 8B 40 1C    MOV     EAX, DWORD PTR 0000001C[EAX]
00089: 0119 C7 00 00000044 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7RPath@@6B@+00000044
00090: 011F 89 5D 88    MOV     DWORD PTR FFFFFF88[EBP], EBX
00091: 0122 81 45 88 000000EC ADD DWORD PTR FFFFFF88[EBP], 000000EC
00092: 0129             NOOP    
00093: 0129 8B 55 88    MOV     EDX, DWORD PTR FFFFFF88[EBP]
00094: 012C 89 D0       MOV     EAX, EDX
00095: 012E 89 38       MOV     DWORD PTR 00000000[EAX], EDI
00096: 0130 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7?$TQList@PAUSSoundBuffer@@@@6B@+00000008
00097: 0136 C7 42 08 00000000 MOV DWORD PTR 00000008[EDX], 00000000
00098: 013D C7 42 0C 00000000 MOV DWORD PTR 0000000C[EDX], 00000000
00099: 0144 C7 42 04 00000000 MOV DWORD PTR 00000004[EDX], 00000000
00101: 014B 05 00000010 ADD     EAX, 00000010
00100: 0150 6A 01       PUSH    00000001
00102: 0152 89 C1       MOV     ECX, EAX
00103: 0154 E8 00000000 CALL    NEAR PTR ??0RSem@@QAE@I@Z
00104: 0159                    
00105: 0159 83 C4 04    ADD     ESP, 00000004
00106: 015C             NOOP    
00107: 015C 8D BB 0000010CLEA   EDI, DWORD PTR 0000010C[EBX]
00108: 0162             NOOP    
00109: 0162 6A 02       PUSH    00000002
00110: 0164             NOOP    
00111: 0164 8D 83 000000ECLEA   EAX, DWORD PTR 000000EC[EBX]
00113: 016A 89 F9       MOV     ECX, EDI
00112: 016C 50          PUSH    EAX
00114: 016D E8 00000000 CALL    NEAR PTR ??0RSoundRecord@@QAE@AAUSSharedSoundBuffer@@W4ESoundDevice@@@Z
00115: 0172                    
00116: 0172 83 C4 08    ADD     ESP, 00000008
00117: 0175 C7 07 00000008 MOV  DWORD PTR 00000000[EDI], OFFSET ??_7CSoundRecord@@6B@+00000008
00118: 017B             NOOP    
00119: 017B 8D 83 00000124LEA   EAX, DWORD PTR 00000124[EBX]
00120: 0181 89 C1       MOV     ECX, EAX
00121: 0183 E8 00000000 CALL    NEAR PTR ??0CAdpcmCodec@@QAE@XZ
00122: 0188                    
:RThread(),
							 CMoteurDocument(),
							 mOffscreen(K_BITMAP_BUFFER),
							 mDocumentPath(path),
							 mSoundRecord(mSharedSoundBuffer)
//***************************************************************************
{
	mDiffBuffer = NULL;
00124: 0188 C7 83 0000009C00000000 MOV DWORD PTR 0000009C[EBX], 00000000
mDiffBuffer = NULL;
	mDiffLen = 0;
00126: 0192 C7 83 000000A000000000 MOV DWORD PTR 000000A0[EBX], 00000000
mDiffLen = 0;
	mDisplay = NULL;
00128: 019C C7 43 5C 00000000 MOV DWORD PTR 0000005C[EBX], 00000000
mDisplay = NULL;
	mDisplayType = kDisplayWindow;
00130: 01A3 C7 43 50 00000000 MOV DWORD PTR 00000050[EBX], 00000000
mDisplayType = kDisplayWindow;
	mDisplaySx = K_SX;
00132: 01AA C7 43 54 00000280 MOV DWORD PTR 00000054[EBX], 00000280
mDisplaySx = K_SX;
	mDisplaySy = K_SY;
00134: 01B1 C7 43 58 000001E0 MOV DWORD PTR 00000058[EBX], 000001E0
mDisplaySy = K_SY;
	mPreviousImg = NULL;
00136: 01B8 C7 83 0000009400000000 MOV DWORD PTR 00000094[EBX], 00000000
mPreviousImg = NULL;
	mCurrentImg  = NULL;
00138: 01C2 C7 83 0000009800000000 MOV DWORD PTR 00000098[EBX], 00000000
mCurrentImg  = NULL;
	mMouseX = 0;
00140: 01CC C7 83 000000A400000000 MOV DWORD PTR 000000A4[EBX], 00000000
mMouseX = 0;
	mMouseY = 0;
00142: 01D6 C7 83 000000A800000000 MOV DWORD PTR 000000A8[EBX], 00000000
mMouseY = 0;
	mMouseVisible = false;
00144: 01E0 C6 83 000000AC00 MOV BYTE PTR 000000AC[EBX], 00000000
mMouseVisible = false;
	mFrameDiffTotal = 0;
00146: 01E7 C7 83 000000D400000000 MOV DWORD PTR 000000D4[EBX], 00000000
mFrameDiffTotal = 0;
	mFrameDiffService = 0;
00148: 01F1 C7 83 000000D800000000 MOV DWORD PTR 000000D8[EBX], 00000000
mFrameDiffService = 0;
	mFrameCount = 0;
00150: 01FB C7 83 000000DC00000000 MOV DWORD PTR 000000DC[EBX], 00000000
mFrameCount = 0;
	mUseSound = true;
00152: 0205 C6 83 000000E001 MOV BYTE PTR 000000E0[EBX], 00000001
mUseSound = true;
	mMemoryPool = NULL;
00154: 020C C7 83 000000E400000000 MOV DWORD PTR 000000E4[EBX], 00000000
mMemoryPool = NULL;
	mMemoryPoolSize = 0;
00156: 0216 C7 83 000000E800000000 MOV DWORD PTR 000000E8[EBX], 00000000
mMemoryPoolSize = 0;

	// be specific
	mOldColorSpace = B_NO_COLOR_SPACE;
00158: 0220 C7 83 0000013000000000 MOV DWORD PTR 00000130[EBX], 00000000
mOldColorSpace = B_NO_COLOR_SPACE;
	mScreenId = B_MAIN_SCREEN_ID;
00160: 022A A1 00000000 MOV     EAX, DWORD PTR __imp_?B_MAIN_SCREEN_ID@@3Uscreen_id@@B
00161: 022F 8B 00       MOV     EAX, DWORD PTR 00000000[EAX]
00162: 0231 89 83 0000012CMOV   DWORD PTR 0000012C[EBX], EAX
mScreenId = B_MAIN_SCREEN_ID;

	// init

	si32 n = K_BITMAP_BUFFER;
00164: 0237 C7 45 8C 00000003 MOV DWORD PTR FFFFFF8C[EBP], 00000003
 n = K_BITMAP_BUFFER;

	printf("CMoteurRecord::init -- moteur %p, name %s\n", this, class_name(this));
00166: 023E 6A 00       PUSH    00000000
00167: 0240 53          PUSH    EBX
00168: 0241 E8 00000000 CALL    NEAR PTR ___get_typeid
00169: 0246                    
00170: 0246 83 C4 08    ADD     ESP, 00000008
00171: 0249             NOOP    
00172: 0249             NOOP    
00173: 0249 89 C1       MOV     ECX, EAX
00174: 024B FF 15 00000000 CALL DWORD PTR __imp_?name@type_info@@QBEPBDXZ
00175: 0251                    
00176: 0251             NOOP    
00177: 0251             NOOP    
00178: 0251 50          PUSH    EAX
00179: 0252 53          PUSH    EBX
00180: 0253 68 00000000 PUSH    OFFSET .data+00000000
00181: 0258 FF 15 00000000 CALL DWORD PTR __imp__printf
00182: 025E                    
00183: 025E 83 C4 0C    ADD     ESP, 0000000C
printf("CMoteurRecord::init -- moteur %p, name %s\n", this, class_name(this));

	mDiffBuffer = new ui8[K_SX*K_SY*2];
00185: 0261 68 00096000 PUSH    00096000
00186: 0266 E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00187: 026B                    
00188: 026B 83 C4 04    ADD     ESP, 00000004
00189: 026E             NOOP    
00190: 026E             NOOP    
00191: 026E 89 83 0000009CMOV   DWORD PTR 0000009C[EBX], EAX
mDiffBuffer = new ui8[K_SX*K_SY*2];
	M_ASSERT_PTR(mDiffBuffer);
00193: 0274 83 BB 0000009C00 CMP DWORD PTR 0000009C[EBX], 00000000
00194: 027B 75 47       JNE     L0002
00198: 027D 8D 45 C0    LEA     EAX, DWORD PTR FFFFFFC0[EBP]
00195: 0280 6A 41       PUSH    00000041
00196: 0282 68 00000000 PUSH    OFFSET .data+0000002c
00197: 0287 68 00000000 PUSH    OFFSET .data+00000040
00199: 028C 89 C1       MOV     ECX, EAX
00200: 028E E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00201: 0293                    
00202: 0293 83 C4 0C    ADD     ESP, 0000000C
00203: 0296 BF 00000008 MOV     EDI, OFFSET ??_7RErrEx@@6B@+00000008
00204: 029B 89 7D 90    MOV     DWORD PTR FFFFFF90[EBP], EDI
00205: 029E 8B 45 C4    MOV     EAX, DWORD PTR FFFFFFC4[EBP]
00206: 02A1 89 45 94    MOV     DWORD PTR FFFFFF94[EBP], EAX
00207: 02A4 8B 45 C8    MOV     EAX, DWORD PTR FFFFFFC8[EBP]
00208: 02A7 89 45 98    MOV     DWORD PTR FFFFFF98[EBP], EAX
00209: 02AA BA 00000000 MOV     EDX, OFFSET .data+0000004c
00211: 02AF 8D 45 90    LEA     EAX, DWORD PTR FFFFFF90[EBP]
00210: 02B2 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00212: 02B7 50          PUSH    EAX
00213: 02B8 52          PUSH    EDX
00214: 02B9 E8 00000000 CALL    NEAR PTR ___throw
00215: 02BE                    
00216: 02BE 83 C4 0C    ADD     ESP, 0000000C
00217: 02C1 89 7D C0    MOV     DWORD PTR FFFFFFC0[EBP], EDI
00218: 02C4     L0002
;

	mPreviousImg = new RBitmap(K_SX, K_SY, kPixel256);
00220: 02C4 6A 60       PUSH    00000060
00221: 02C6 E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00222: 02CB                    
00223: 02CB 83 C4 04    ADD     ESP, 00000004
00224: 02CE             NOOP    
00225: 02CE             NOOP    
00226: 02CE 89 C7       MOV     EDI, EAX
00227: 02D0 09 FF       OR      EDI, EDI
00228: 02D2 74 1D       JE      L0003
00234: 02D4 89 F9       MOV     ECX, EDI
00229: 02D6 6A 00       PUSH    00000000
00230: 02D8 68 00000800 PUSH    00000800
00231: 02DD 68 000001E0 PUSH    000001E0
00232: 02E2 68 00000280 PUSH    00000280
00233: 02E7 6A 01       PUSH    00000001
00235: 02E9 E8 00000000 CALL    NEAR PTR ??0RBitmap@@QAE@IKKKE@Z
00236: 02EE                    
00237: 02EE 83 C4 14    ADD     ESP, 00000014
00238: 02F1     L0003
00239: 02F1 89 BB 00000094MOV   DWORD PTR 00000094[EBX], EDI
mPreviousImg = new RBitmap(K_SX, K_SY, kPixel256);
	mCurrentImg  = new RBitmap(K_SX, K_SY, kPixel256);
00241: 02F7 6A 60       PUSH    00000060
00242: 02F9 E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00243: 02FE                    
00244: 02FE 83 C4 04    ADD     ESP, 00000004
00245: 0301             NOOP    
00246: 0301             NOOP    
00247: 0301 89 C7       MOV     EDI, EAX
00248: 0303 09 FF       OR      EDI, EDI
00249: 0305 74 1D       JE      L0004
00255: 0307 89 F9       MOV     ECX, EDI
00250: 0309 6A 00       PUSH    00000000
00251: 030B 68 00000800 PUSH    00000800
00252: 0310 68 000001E0 PUSH    000001E0
00253: 0315 68 00000280 PUSH    00000280
00254: 031A 6A 01       PUSH    00000001
00256: 031C E8 00000000 CALL    NEAR PTR ??0RBitmap@@QAE@IKKKE@Z
00257: 0321                    
00258: 0321 83 C4 14    ADD     ESP, 00000014
00259: 0324     L0004
00260: 0324 89 BB 00000098MOV   DWORD PTR 00000098[EBX], EDI
mCurrentImg  = new RBitmap(K_SX, K_SY, kPixel256);
	M_ASSERT_PTR(mPreviousImg);
00262: 032A 83 BB 0000009400 CMP DWORD PTR 00000094[EBX], 00000000
00263: 0331 75 47       JNE     L0005
00267: 0333 8D 45 CC    LEA     EAX, DWORD PTR FFFFFFCC[EBP]
00264: 0336 6A 45       PUSH    00000045
00265: 0338 68 00000000 PUSH    OFFSET .data+00000058
00266: 033D 68 00000000 PUSH    OFFSET .data+0000006c
00268: 0342 89 C1       MOV     ECX, EAX
00269: 0344 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00270: 0349                    
00271: 0349 83 C4 0C    ADD     ESP, 0000000C
00272: 034C BF 00000008 MOV     EDI, OFFSET ??_7RErrEx@@6B@+00000008
00273: 0351 89 7D 9C    MOV     DWORD PTR FFFFFF9C[EBP], EDI
00274: 0354 8B 45 D0    MOV     EAX, DWORD PTR FFFFFFD0[EBP]
00275: 0357 89 45 A0    MOV     DWORD PTR FFFFFFA0[EBP], EAX
00276: 035A 8B 45 D4    MOV     EAX, DWORD PTR FFFFFFD4[EBP]
00277: 035D 89 45 A4    MOV     DWORD PTR FFFFFFA4[EBP], EAX
00278: 0360 BA 00000000 MOV     EDX, OFFSET .data+0000007c
00280: 0365 8D 45 9C    LEA     EAX, DWORD PTR FFFFFF9C[EBP]
00279: 0368 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00281: 036D 50          PUSH    EAX
00282: 036E 52          PUSH    EDX
00283: 036F E8 00000000 CALL    NEAR PTR ___throw
00284: 0374                    
00285: 0374 83 C4 0C    ADD     ESP, 0000000C
00286: 0377 89 7D CC    MOV     DWORD PTR FFFFFFCC[EBP], EDI
00287: 037A     L0005
;
	M_ASSERT_PTR(mCurrentImg );
00289: 037A 83 BB 0000009800 CMP DWORD PTR 00000098[EBX], 00000000
00290: 0381 75 47       JNE     L0006
00294: 0383 8D 45 D8    LEA     EAX, DWORD PTR FFFFFFD8[EBP]
00291: 0386 6A 46       PUSH    00000046
00292: 0388 68 00000000 PUSH    OFFSET .data+00000088
00293: 038D 68 00000000 PUSH    OFFSET .data+0000009c
00295: 0392 89 C1       MOV     ECX, EAX
00296: 0394 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00297: 0399                    
00298: 0399 83 C4 0C    ADD     ESP, 0000000C
00299: 039C BF 00000008 MOV     EDI, OFFSET ??_7RErrEx@@6B@+00000008
00300: 03A1 89 7D A8    MOV     DWORD PTR FFFFFFA8[EBP], EDI
00301: 03A4 8B 45 DC    MOV     EAX, DWORD PTR FFFFFFDC[EBP]
00302: 03A7 89 45 AC    MOV     DWORD PTR FFFFFFAC[EBP], EAX
00303: 03AA 8B 45 E0    MOV     EAX, DWORD PTR FFFFFFE0[EBP]
00304: 03AD 89 45 B0    MOV     DWORD PTR FFFFFFB0[EBP], EAX
00305: 03B0 BA 00000000 MOV     EDX, OFFSET .data+000000a8
00307: 03B5 8D 45 A8    LEA     EAX, DWORD PTR FFFFFFA8[EBP]
00306: 03B8 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00308: 03BD 50          PUSH    EAX
00309: 03BE 52          PUSH    EDX
00310: 03BF E8 00000000 CALL    NEAR PTR ___throw
00311: 03C4                    
00312: 03C4 83 C4 0C    ADD     ESP, 0000000C
00313: 03C7 89 7D D8    MOV     DWORD PTR FFFFFFD8[EBP], EDI
00314: 03CA     L0006
;

  for(n--; n>=0; n--)
00316: 03CA FF 4D 8C    DEC     DWORD PTR FFFFFF8C[EBP]
00317: 03CD BF 00000008 MOV     EDI, OFFSET ??_7RErrEx@@6B@+00000008
00318: 03D2 E9 000000FF JMP     L0007
00319: 03D7     L0008
for(n--; n>=0; n--)
	{
		RBitmap *map = new RBitmap(K_SX, K_SY, kPixel256);
00321: 03D7 6A 60       PUSH    00000060
00322: 03D9 E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00323: 03DE                    
00324: 03DE 83 C4 04    ADD     ESP, 00000004
00325: 03E1             NOOP    
00326: 03E1             NOOP    
00327: 03E1 89 45 84    MOV     DWORD PTR FFFFFF84[EBP], EAX
00328: 03E4 09 C0       OR      EAX, EAX
00329: 03E6 74 1D       JE      L0009
00335: 03E8 89 C1       MOV     ECX, EAX
00330: 03EA 6A 00       PUSH    00000000
00331: 03EC 68 00000800 PUSH    00000800
00332: 03F1 68 000001E0 PUSH    000001E0
00333: 03F6 68 00000280 PUSH    00000280
00334: 03FB 6A 01       PUSH    00000001
00336: 03FD E8 00000000 CALL    NEAR PTR ??0RBitmap@@QAE@IKKKE@Z
00337: 0402                    
00338: 0402 83 C4 14    ADD     ESP, 00000014
00339: 0405     L0009
RBitmap *map = new RBitmap(K_SX, K_SY, kPixel256);
		M_ASSERT_PTR(map);
00341: 0405 83 7D 84 00 CMP     DWORD PTR FFFFFF84[EBP], 00000000
00342: 0409 75 42       JNE     L000A
00346: 040B 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00343: 040E 6A 4B       PUSH    0000004B
00344: 0410 68 00000000 PUSH    OFFSET .data+000000b4
00345: 0415 68 00000000 PUSH    OFFSET .data+000000c8
00347: 041A 89 C1       MOV     ECX, EAX
00348: 041C E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00349: 0421                    
00350: 0421 83 C4 0C    ADD     ESP, 0000000C
00351: 0424 89 7D B4    MOV     DWORD PTR FFFFFFB4[EBP], EDI
00352: 0427 8B 45 E8    MOV     EAX, DWORD PTR FFFFFFE8[EBP]
00353: 042A 89 45 B8    MOV     DWORD PTR FFFFFFB8[EBP], EAX
00354: 042D 8B 45 EC    MOV     EAX, DWORD PTR FFFFFFEC[EBP]
00355: 0430 89 45 BC    MOV     DWORD PTR FFFFFFBC[EBP], EAX
00356: 0433 BA 00000000 MOV     EDX, OFFSET .data+000000cc
00358: 0438 8D 45 B4    LEA     EAX, DWORD PTR FFFFFFB4[EBP]
00357: 043B 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00359: 0440 50          PUSH    EAX
00360: 0441 52          PUSH    EDX
00361: 0442 E8 00000000 CALL    NEAR PTR ___throw
00362: 0447                    
00363: 0447 83 C4 0C    ADD     ESP, 0000000C
00364: 044A 89 7D E4    MOV     DWORD PTR FFFFFFE4[EBP], EDI
00365: 044D     L000A
;
		map->erase();
00367: 044D A0 00000004 MOV     AL, BYTE PTR ?gBlack@@3URColor@@B+00000004
00370: 0452 8B 4D 84    MOV     ECX, DWORD PTR FFFFFF84[EBP]
00368: 0455 50          PUSH    EAX
00369: 0456 FF 35 00000000 PUSH DWORD PTR ?gBlack@@3URColor@@B
00371: 045C E8 00000000 CALL    NEAR PTR ?erase@RBitmap@@QAEXURColor@@@Z
00372: 0461                    
00373: 0461 83 C4 08    ADD     ESP, 00000008
map->erase();
		mOffscreen.initItemAt(n, map);
00375: 0464 8B 53 78    MOV     EDX, DWORD PTR 00000078[EBX]
00376: 0467 09 D2       OR      EDX, EDX
00377: 0469 74 15       JE      L000B
00378: 046B 8B 45 8C    MOV     EAX, DWORD PTR FFFFFF8C[EBP]
00379: 046E 3B 43 70    CMP     EAX, DWORD PTR 00000070[EBX]
00380: 0471 7D 0D       JGE     L000B
00381: 0473 89 C1       MOV     ECX, EAX
00382: 0475 8B 04 8A    MOV     EAX, DWORD PTR 00000000[EDX][ECX*4]
00383: 0478 89 85 FFFFFF7CMOV   DWORD PTR FFFFFF7C[EBP], EAX
00384: 047E EB 0A       JMP     L000C
00385: 0480     L000B
00386: 0480 C7 85 FFFFFF7C00000000 MOV DWORD PTR FFFFFF7C[EBP], 00000000
00387: 048A     L000C
00388: 048A 83 BD FFFFFF7C00 CMP DWORD PTR FFFFFF7C[EBP], 00000000
00389: 0491 75 35       JNE     L000D
00390: 0493 6A 0C       PUSH    0000000C
00391: 0495 E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00392: 049A                    
00393: 049A 83 C4 04    ADD     ESP, 00000004
00394: 049D             NOOP    
00395: 049D             NOOP    
00396: 049D             NOOP    
00397: 049D 09 C0       OR      EAX, EAX
00398: 049F 74 10       JE      L000E
00399: 04A1 89 38       MOV     DWORD PTR 00000000[EAX], EDI
00400: 04A3 C7 40 04 10000005 MOV DWORD PTR 00000004[EAX], 10000005
00401: 04AA C7 40 08 00000000 MOV DWORD PTR 00000008[EAX], OFFSET .data+000000d8
00402: 04B1     L000E
00403: 04B1 89 45 F0    MOV     DWORD PTR FFFFFFF0[EBP], EAX
00404: 04B4 BA 00000000 MOV     EDX, OFFSET .data+000000e4
00406: 04B9 8D 45 F0    LEA     EAX, DWORD PTR FFFFFFF0[EBP]
00405: 04BC 6A 00       PUSH    00000000
00407: 04BE 50          PUSH    EAX
00408: 04BF 52          PUSH    EDX
00409: 04C0 E8 00000000 CALL    NEAR PTR ___throw
00410: 04C5                    
00411: 04C5 83 C4 0C    ADD     ESP, 0000000C
00412: 04C8     L000D
00413: 04C8 8B 4D 84    MOV     ECX, DWORD PTR FFFFFF84[EBP]
00414: 04CB 8B 85 FFFFFF7CMOV   EAX, DWORD PTR FFFFFF7C[EBP]
00415: 04D1 89 08       MOV     DWORD PTR 00000000[EAX], ECX
mOffscreen.initItemAt(n, map);
	}
00417: 04D3 FF 4D 8C    DEC     DWORD PTR FFFFFF8C[EBP]
00418: 04D6     L0007
00419: 04D6 83 7D 8C 00 CMP     DWORD PTR FFFFFF8C[EBP], 00000000
00420: 04DA 0F 8D FFFFFEF7 JGE  L0008
}

	setThread(this);
00422: 04E0 89 5B 4C    MOV     DWORD PTR 0000004C[EBX], EBX
setThread(this);

} // end of constructor for CMoteurRecord
00424: 04E3 89 D8       MOV     EAX, EBX
00425: 04E5     L0000
00426: 04E5 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00427: 04E8 5F          POP     EDI
00428: 04E9 5E          POP     ESI
00429: 04EA 5B          POP     EBX
00430: 04EB 5D          POP     EBP
00431: 04EC C3          RETN    

Function: ??1CMoteurRecord@@UAE@XZ
} // end of constructor for CMoteurRecord


//***************************************************************************
CMoteurRecord::~CMoteurRecord(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 89 CB       MOV     EBX, ECX
00008: 0008 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7CMoteurRecord@@6B@+00000008
00009: 000E 8B 43 04    MOV     EAX, DWORD PTR 00000004[EBX]
00010: 0011 C7 00 00000024 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7CMoteurRecord@@6B@+00000024
00011: 0017 C7 43 40 00000018 MOV DWORD PTR 00000040[EBX], OFFSET ??_7CMoteurRecord@@6B@+00000018
{
	if (mCurrentImg ) delete mCurrentImg ; mCurrentImg  = NULL;
00013: 001E 8B 83 00000098MOV   EAX, DWORD PTR 00000098[EBX]
00014: 0024 09 C0       OR      EAX, EAX
00015: 0026 74 0F       JE      L0001
if (mCurrentImg ) delete mCurrentImg ; mCurrentImg  = NULL;
00017: 0028 09 C0       OR      EAX, EAX
00018: 002A 74 0B       JE      L0002
00020: 002C 89 C1       MOV     ECX, EAX
00019: 002E 6A 01       PUSH    00000001
00021: 0030 8B 31       MOV     ESI, DWORD PTR 00000000[ECX]
00022: 0032 FF 16       CALL    DWORD PTR 00000000[ESI]
00023: 0034 83 C4 04    ADD     ESP, 00000004
00024: 0037     L0002
00025: 0037     L0001
delete mCurrentImg ; mCurrentImg  = NULL;
00027: 0037 C7 83 0000009800000000 MOV DWORD PTR 00000098[EBX], 00000000
mCurrentImg  = NULL;
	if (mPreviousImg) delete mPreviousImg; mPreviousImg = NULL;
00029: 0041 8B 83 00000094MOV   EAX, DWORD PTR 00000094[EBX]
00030: 0047 09 C0       OR      EAX, EAX
00031: 0049 74 0F       JE      L0003
if (mPreviousImg) delete mPreviousImg; mPreviousImg = NULL;
00033: 004B 09 C0       OR      EAX, EAX
00034: 004D 74 0B       JE      L0004
00036: 004F 89 C1       MOV     ECX, EAX
00035: 0051 6A 01       PUSH    00000001
00037: 0053 8B 31       MOV     ESI, DWORD PTR 00000000[ECX]
00038: 0055 FF 16       CALL    DWORD PTR 00000000[ESI]
00039: 0057 83 C4 04    ADD     ESP, 00000004
00040: 005A     L0004
00041: 005A     L0003
delete mPreviousImg; mPreviousImg = NULL;
00043: 005A C7 83 0000009400000000 MOV DWORD PTR 00000094[EBX], 00000000
mPreviousImg = NULL;
	if (mDiffBuffer ) delete mDiffBuffer ; mDiffBuffer  = NULL;
00045: 0064 8B 83 0000009CMOV   EAX, DWORD PTR 0000009C[EBX]
00046: 006A 09 C0       OR      EAX, EAX
00047: 006C 74 09       JE      L0005
if (mDiffBuffer ) delete mDiffBuffer ; mDiffBuffer  = NULL;
00049: 006E 50          PUSH    EAX
00050: 006F E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00051: 0074 83 C4 04    ADD     ESP, 00000004
00052: 0077     L0005
delete mDiffBuffer ; mDiffBuffer  = NULL;
00054: 0077 C7 83 0000009C00000000 MOV DWORD PTR 0000009C[EBX], 00000000
00055: 0081             NOOP    
00056: 0081 8D 83 00000124LEA   EAX, DWORD PTR 00000124[EBX]
00057: 0087 89 C1       MOV     ECX, EAX
00058: 0089 E8 00000000 CALL    NEAR PTR ??1CAdpcmCodec@@UAE@XZ
00059: 008E C7 83 0000010C00000008 MOV DWORD PTR 0000010C[EBX], OFFSET ??_7CSoundRecord@@6B@+00000008
00060: 0098             NOOP    
00061: 0098 8D 83 0000010CLEA   EAX, DWORD PTR 0000010C[EBX]
00062: 009E 89 C1       MOV     ECX, EAX
00063: 00A0 E8 00000000 CALL    NEAR PTR ??1RSoundRecord@@UAE@XZ
00064: 00A5             NOOP    
00065: 00A5 8D 83 0000010CLEA   EAX, DWORD PTR 0000010C[EBX]
00066: 00AB             NOOP    
00067: 00AB 8D B3 000000ECLEA   ESI, DWORD PTR 000000EC[EBX]
00068: 00B1 83 C6 10    ADD     ESI, 00000010
00069: 00B4             NOOP    
00070: 00B4 89 F1       MOV     ECX, ESI
00071: 00B6 E8 00000000 CALL    NEAR PTR ??1RSem@@UAE@XZ
00072: 00BB BF 00000008 MOV     EDI, OFFSET ??_7RInterface@@6B@+00000008
00073: 00C0 89 BB 00000108MOV   DWORD PTR 00000108[EBX], EDI
00074: 00C6             NOOP    
00075: 00C6 8D 46 0C    LEA     EAX, DWORD PTR 0000000C[ESI]
00076: 00C9             NOOP    
00077: 00C9 8D 83 000000ECLEA   EAX, DWORD PTR 000000EC[EBX]
00078: 00CF 05 00000010 ADD     EAX, 00000010
00079: 00D4 C7 83 000000EC00000008 MOV DWORD PTR 000000EC[EBX], OFFSET ??_7?$TQList@PAUSSoundBuffer@@@@6B@+00000008
00080: 00DE EB 0D       JMP     L0006
00081: 00E0     L0007
00082: 00E0             NOOP    
00083: 00E0 8D 83 000000ECLEA   EAX, DWORD PTR 000000EC[EBX]
00084: 00E6 89 C1       MOV     ECX, EAX
00085: 00E8 E8 00000000 CALL    NEAR PTR ?removeFirst@?$TQList@PAUSSoundBuffer@@@@QAEPAUSSoundBuffer@@XZ
00086: 00ED     L0006
00087: 00ED 83 BB 000000F400 CMP DWORD PTR 000000F4[EBX], 00000000
00088: 00F4 0F 94 C0    SETE    AL
00089: 00F7 08 C0       OR      AL, AL
00090: 00F9 74 E5       JE      L0007
00091: 00FB 89 BB 000000ECMOV   DWORD PTR 000000EC[EBX], EDI
00092: 0101             NOOP    
00093: 0101 8D 83 000000ECLEA   EAX, DWORD PTR 000000EC[EBX]
00094: 0107             NOOP    
00095: 0107 8D 83 000000ECLEA   EAX, DWORD PTR 000000EC[EBX]
00096: 010D             NOOP    
00097: 010D 8D 83 000000ECLEA   EAX, DWORD PTR 000000EC[EBX]
00098: 0113 C7 83 000000B000000008 MOV DWORD PTR 000000B0[EBX], OFFSET ??_7RPath@@6B@+00000008
00099: 011D 8B 83 000000CCMOV   EAX, DWORD PTR 000000CC[EBX]
00100: 0123 C7 00 00000044 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7RPath@@6B@+00000044
00101: 0129             NOOP    
00102: 0129 8D 83 000000B0LEA   EAX, DWORD PTR 000000B0[EBX]
00103: 012F 89 C1       MOV     ECX, EAX
00104: 0131 FF 15 00000000 CALL DWORD PTR __imp_??1BPath@@UAE@XZ
00105: 0137             NOOP    
00106: 0137 8D 83 000000B0LEA   EAX, DWORD PTR 000000B0[EBX]
00107: 013D 89 BB 000000D0MOV   DWORD PTR 000000D0[EBX], EDI
00108: 0143             NOOP    
00109: 0143 8D 83 000000B0LEA   EAX, DWORD PTR 000000B0[EBX]
00110: 0149 05 00000020 ADD     EAX, 00000020
00111: 014E             NOOP    
00112: 014E 8D 83 000000B0LEA   EAX, DWORD PTR 000000B0[EBX]
00113: 0154 C7 43 60 00000008 MOV DWORD PTR 00000060[EBX], OFFSET ??_7?$TRotateBuffer@PAVRBitmap@@@@6B@+00000008
00114: 015B             NOOP    
00115: 015B 8D 43 60    LEA     EAX, DWORD PTR 00000060[EBX]
00116: 015E 89 C1       MOV     ECX, EAX
00117: 0160 E8 00000000 CALL    NEAR PTR ?makeEmpty@?$TRotateBuffer@PAVRBitmap@@@@IAEXXZ
00118: 0165 C7 43 64 00000000 MOV DWORD PTR 00000064[EBX], 00000000
00119: 016C             NOOP    
00120: 016C 8D 73 60    LEA     ESI, DWORD PTR 00000060[EBX]
00121: 016F 83 C6 24    ADD     ESI, 00000024
00122: 0172             NOOP    
00123: 0172 89 F1       MOV     ECX, ESI
00124: 0174 E8 00000000 CALL    NEAR PTR ??1RSem@@UAE@XZ
00125: 0179 89 BB 00000090MOV   DWORD PTR 00000090[EBX], EDI
00126: 017F             NOOP    
00127: 017F 8D 46 0C    LEA     EAX, DWORD PTR 0000000C[ESI]
00128: 0182             NOOP    
00129: 0182 8D 43 60    LEA     EAX, DWORD PTR 00000060[EBX]
00131: 0185 C7 43 68 00000008 MOV DWORD PTR 00000068[EBX], OFFSET ??_7?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@6B@+00000008
00130: 018C 05 00000024 ADD     EAX, 00000024
00132: 0191 83 7B 78 00 CMP     DWORD PTR 00000078[EBX], 00000000
00133: 0195 74 0C       JE      L0008
00134: 0197 8B 43 78    MOV     EAX, DWORD PTR 00000078[EBX]
00135: 019A 50          PUSH    EAX
00136: 019B E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00137: 01A0 83 C4 04    ADD     ESP, 00000004
00138: 01A3     L0008
00139: 01A3 C7 43 74 00000000 MOV DWORD PTR 00000074[EBX], 00000000
00140: 01AA 8B 43 74    MOV     EAX, DWORD PTR 00000074[EBX]
00161: 01AD 89 D9       MOV     ECX, EBX
00141: 01AF 89 43 70    MOV     DWORD PTR 00000070[EBX], EAX
00142: 01B2 89 7B 68    MOV     DWORD PTR 00000068[EBX], EDI
00143: 01B5             NOOP    
00144: 01B5 8D 43 60    LEA     EAX, DWORD PTR 00000060[EBX]
00145: 01B8 05 00000008 ADD     EAX, 00000008
00146: 01BD             NOOP    
00147: 01BD 8D 43 60    LEA     EAX, DWORD PTR 00000060[EBX]
00149: 01C0 89 7B 60    MOV     DWORD PTR 00000060[EBX], EDI
00148: 01C3 05 00000008 ADD     EAX, 00000008
00150: 01C8             NOOP    
00151: 01C8 8D 43 60    LEA     EAX, DWORD PTR 00000060[EBX]
00152: 01CB             NOOP    
00153: 01CB 8D 43 60    LEA     EAX, DWORD PTR 00000060[EBX]
00154: 01CE C7 43 40 00000008 MOV DWORD PTR 00000040[EBX], OFFSET ??_7CMoteurDocument@@6B@+00000008
00155: 01D5 8B 43 44    MOV     EAX, DWORD PTR 00000044[EBX]
00156: 01D8 C7 00 00000014 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7CMoteurDocument@@6B@+00000014
00157: 01DE C7 43 48 00000000 MOV DWORD PTR 00000048[EBX], 00000000
00158: 01E5 C7 43 4C 00000000 MOV DWORD PTR 0000004C[EBX], 00000000
00159: 01EC             NOOP    
00160: 01EC 8D 43 40    LEA     EAX, DWORD PTR 00000040[EBX]
00162: 01EF E8 00000000 CALL    NEAR PTR ??1RThread@@UAE@XZ
00163: 01F4 89 D8       MOV     EAX, EBX
00164: 01F6     L0000
00165: 01F6 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00166: 01F9 5F          POP     EDI
00167: 01FA 5E          POP     ESI
00168: 01FB 5B          POP     EBX
00169: 01FC 5D          POP     EBP
00170: 01FD C3          RETN    

Function: ?initFile@CMoteurRecord@@IAEXAAPAU_FILE@@@Z
mDiffBuffer  = NULL;

} // end of destructor for CMoteurRecord


//---------------------------------------------------------------------------


//***************************************************************************
void CMoteurRecord::initFile(FILE * &f)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 83 EC 30    SUB     ESP, 00000030
00008: 0009 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00009: 000C 89 CE       MOV     ESI, ECX
{
	f = fopen(mDocumentPath.path(), "wb");
00011: 000E 68 00000000 PUSH    OFFSET .data+000000f0
00012: 0013             NOOP    
00013: 0013 8D 86 000000B0LEA   EAX, DWORD PTR 000000B0[ESI]
00014: 0019 89 C1       MOV     ECX, EAX
00015: 001B FF 15 00000000 CALL DWORD PTR __imp_?Path@BPath@@QBEPBDXZ
00016: 0021             NOOP    
00017: 0021             NOOP    
00018: 0021 50          PUSH    EAX
00019: 0022 FF 15 00000000 CALL DWORD PTR __imp__fopen
00020: 0028 83 C4 08    ADD     ESP, 00000008
00021: 002B             NOOP    
00022: 002B             NOOP    
00023: 002B 89 03       MOV     DWORD PTR 00000000[EBX], EAX
f = fopen(mDocumentPath.path(), "wb");

	printf("File %s open in write mode\n", mDocumentPath.path());
00025: 002D             NOOP    
00026: 002D 8D 86 000000B0LEA   EAX, DWORD PTR 000000B0[ESI]
00027: 0033 89 C1       MOV     ECX, EAX
00028: 0035 FF 15 00000000 CALL DWORD PTR __imp_?Path@BPath@@QBEPBDXZ
00029: 003B             NOOP    
00030: 003B             NOOP    
00031: 003B 50          PUSH    EAX
00032: 003C 68 00000000 PUSH    OFFSET .data+000000f4
00033: 0041 FF 15 00000000 CALL DWORD PTR __imp__printf
00034: 0047 83 C4 08    ADD     ESP, 00000008
printf("File %s open in write mode\n", mDocumentPath.path());
	M_ASSERT_PTR(f);
00036: 004A 83 3B 00    CMP     DWORD PTR 00000000[EBX], 00000000
00037: 004D 75 47       JNE     L0001
00041: 004F 8D 45 DC    LEA     EAX, DWORD PTR FFFFFFDC[EBP]
00038: 0052 6A 6A       PUSH    0000006A
00039: 0054 68 00000000 PUSH    OFFSET .data+00000110
00040: 0059 68 00000000 PUSH    OFFSET .data+00000124
00042: 005E 89 C1       MOV     ECX, EAX
00043: 0060 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00044: 0065 83 C4 0C    ADD     ESP, 0000000C
00045: 0068 BF 00000008 MOV     EDI, OFFSET ??_7RErrEx@@6B@+00000008
00046: 006D 89 7D C4    MOV     DWORD PTR FFFFFFC4[EBP], EDI
00047: 0070 8B 45 E0    MOV     EAX, DWORD PTR FFFFFFE0[EBP]
00048: 0073 89 45 C8    MOV     DWORD PTR FFFFFFC8[EBP], EAX
00049: 0076 8B 45 E4    MOV     EAX, DWORD PTR FFFFFFE4[EBP]
00050: 0079 89 45 CC    MOV     DWORD PTR FFFFFFCC[EBP], EAX
00051: 007C BA 00000000 MOV     EDX, OFFSET .data+00000128
00053: 0081 8D 45 C4    LEA     EAX, DWORD PTR FFFFFFC4[EBP]
00052: 0084 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00054: 0089 50          PUSH    EAX
00055: 008A 52          PUSH    EDX
00056: 008B E8 00000000 CALL    NEAR PTR ___throw
00057: 0090                    
00058: 0090 83 C4 0C    ADD     ESP, 0000000C
00059: 0093 89 7D DC    MOV     DWORD PTR FFFFFFDC[EBP], EDI
00060: 0096     L0001
;

	gApplication->setFileType(mDocumentPath, K_APP_DOC_MIME);
00062: 0096 68 00000000 PUSH    OFFSET .data+00000134
00063: 009B             NOOP    
00064: 009B 8D 86 000000B0LEA   EAX, DWORD PTR 000000B0[ESI]
00066: 00A1 8B 0D 00000000 MOV  ECX, DWORD PTR ?gApplication@@3PAVCApp@@A
00065: 00A7 50          PUSH    EAX
00067: 00A8 E8 00000000 CALL    NEAR PTR ?setFileType@CApp@@QAEXAAVRPath@@PAD@Z
00068: 00AD 83 C4 08    ADD     ESP, 00000008
gApplication->setFileType(mDocumentPath, K_APP_DOC_MIME);

	// write file header
	M_ASSERT_PTR(f_bg_write4(K_FILE_HEADER_SIGNATURE, f) && f_bg_write4(K_FILE_HEADER_VERSION, f));
00070: 00B0 8B 03       MOV     EAX, DWORD PTR 00000000[EBX]
00073: 00B2 89 F1       MOV     ECX, ESI
00071: 00B4 50          PUSH    EAX
00072: 00B5 68 56695368 PUSH    56695368
00074: 00BA E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00075: 00BF 83 C4 08    ADD     ESP, 00000008
00076: 00C2             NOOP    
00077: 00C2             NOOP    
00078: 00C2 08 C0       OR      AL, AL
00079: 00C4 74 13       JE      L0002
00080: 00C6 8B 03       MOV     EAX, DWORD PTR 00000000[EBX]
00083: 00C8 89 F1       MOV     ECX, ESI
00081: 00CA 50          PUSH    EAX
00082: 00CB 6A 01       PUSH    00000001
00084: 00CD E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00085: 00D2 83 C4 08    ADD     ESP, 00000008
00086: 00D5             NOOP    
00087: 00D5             NOOP    
00088: 00D5 08 C0       OR      AL, AL
00089: 00D7 75 47       JNE     L0003
00090: 00D9     L0002
00091: 00D9 6A 6F       PUSH    0000006F
00092: 00DB 68 00000000 PUSH    OFFSET .data+00000160
00093: 00E0 68 00000000 PUSH    OFFSET .data+00000174
00094: 00E5 8D 45 E8    LEA     EAX, DWORD PTR FFFFFFE8[EBP]
00095: 00E8 89 C1       MOV     ECX, EAX
00096: 00EA E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00097: 00EF 83 C4 0C    ADD     ESP, 0000000C
00098: 00F2 BB 00000008 MOV     EBX, OFFSET ??_7RErrEx@@6B@+00000008
00099: 00F7 89 5D D0    MOV     DWORD PTR FFFFFFD0[EBP], EBX
00100: 00FA 8B 45 EC    MOV     EAX, DWORD PTR FFFFFFEC[EBP]
00101: 00FD 89 45 D4    MOV     DWORD PTR FFFFFFD4[EBP], EAX
00102: 0100 8B 45 F0    MOV     EAX, DWORD PTR FFFFFFF0[EBP]
00103: 0103 89 45 D8    MOV     DWORD PTR FFFFFFD8[EBP], EAX
00104: 0106 BA 00000000 MOV     EDX, OFFSET .data+000001c8
00106: 010B 8D 45 D0    LEA     EAX, DWORD PTR FFFFFFD0[EBP]
00105: 010E 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00107: 0113 50          PUSH    EAX
00108: 0114 52          PUSH    EDX
00109: 0115 E8 00000000 CALL    NEAR PTR ___throw
00110: 011A                    
00111: 011A 83 C4 0C    ADD     ESP, 0000000C
00112: 011D 89 5D E8    MOV     DWORD PTR FFFFFFE8[EBP], EBX
00113: 0120     L0003
;

} // end of initFile for CMoteurRecord
00115: 0120     L0000
00116: 0120 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00117: 0123 5F          POP     EDI
00118: 0124 5E          POP     ESI
00119: 0125 5B          POP     EBX
00120: 0126 5D          POP     EBP
00121: 0127 C3          RETN    

Function: ?initSound@CMoteurRecord@@IAEXXZ
} // end of initFile for CMoteurRecord


//***************************************************************************
void CMoteurRecord::initSound(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 83 EC 18    SUB     ESP, 00000018
00007: 0008 89 CB       MOV     EBX, ECX
{
	mUseSound = mSoundRecord.soundDeviceOpen();
00009: 000A             NOOP    
00010: 000A 8D 83 0000010CLEA   EAX, DWORD PTR 0000010C[EBX]
00011: 0010 89 C1       MOV     ECX, EAX
00012: 0012 8B 31       MOV     ESI, DWORD PTR 00000000[ECX]
00013: 0014 FF 56 10    CALL    DWORD PTR 00000010[ESI]
00014: 0017             NOOP    
00015: 0017             NOOP    
00016: 0017 88 83 000000E0MOV   BYTE PTR 000000E0[EBX], AL
mUseSound = mSoundRecord.soundDeviceOpen();
	if (debug && !mUseSound) printf("CMoteurRecord : no sound device open\n");
00018: 001D 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00019: 0024 74 17       JE      L0001
00020: 0026 80 BB 000000E000 CMP BYTE PTR 000000E0[EBX], 00000000
00021: 002D 75 0E       JNE     L0001
if (debug && !mUseSound) printf("CMoteurRecord : no sound device open\n");
00023: 002F 68 00000000 PUSH    OFFSET .data+000001d4
00024: 0034 FF 15 00000000 CALL DWORD PTR __imp__printf
00025: 003A 83 C4 04    ADD     ESP, 00000004
00026: 003D     L0001
printf("CMoteurRecord : no sound device open\n");

	if (mUseSound)
00028: 003D 80 BB 000000E000 CMP BYTE PTR 000000E0[EBX], 00000000
00029: 0044 0F 84 000000B0 JE   L0002
if (mUseSound)
	{
		// adjust the memory pool used for compression/decompression
		// the memory pool contains enough space for one buffer of the Media Kit
		
		mMemoryPoolSize = mSoundRecord.getIdealBufferSize();
00031: 004A             NOOP    
00032: 004A 8D 83 0000010CLEA   EAX, DWORD PTR 0000010C[EBX]
00033: 0050 89 C1       MOV     ECX, EAX
00034: 0052 8B 31       MOV     ESI, DWORD PTR 00000000[ECX]
00035: 0054 FF 56 0C    CALL    DWORD PTR 0000000C[ESI]
00036: 0057             NOOP    
00037: 0057             NOOP    
00038: 0057 89 83 000000E8MOV   DWORD PTR 000000E8[EBX], EAX
mMemoryPoolSize = mSoundRecord.getIdealBufferSize();
		mMemoryPool = new ui8[mMemoryPoolSize];
00040: 005D 8B 83 000000E8MOV   EAX, DWORD PTR 000000E8[EBX]
00041: 0063 C1 E0 00    SHL     EAX, 00000000
00042: 0066 50          PUSH    EAX
00043: 0067 E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00044: 006C 83 C4 04    ADD     ESP, 00000004
00045: 006F             NOOP    
00046: 006F             NOOP    
00047: 006F 89 83 000000E4MOV   DWORD PTR 000000E4[EBX], EAX
mMemoryPool = new ui8[mMemoryPoolSize];
		M_ASSERT_PTR(mMemoryPool);
00049: 0075 83 BB 000000E400 CMP DWORD PTR 000000E4[EBX], 00000000
00050: 007C 75 4A       JNE     L0003
00054: 007E 8D 45 EC    LEA     EAX, DWORD PTR FFFFFFEC[EBP]
00051: 0081 68 00000082 PUSH    00000082
00052: 0086 68 00000000 PUSH    OFFSET .data+000001fc
00053: 008B 68 00000000 PUSH    OFFSET .data+00000210
00055: 0090 89 C1       MOV     ECX, EAX
00056: 0092 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00057: 0097 83 C4 0C    ADD     ESP, 0000000C
00058: 009A BE 00000008 MOV     ESI, OFFSET ??_7RErrEx@@6B@+00000008
00059: 009F 89 75 E0    MOV     DWORD PTR FFFFFFE0[EBP], ESI
00060: 00A2 8B 45 F0    MOV     EAX, DWORD PTR FFFFFFF0[EBP]
00061: 00A5 89 45 E4    MOV     DWORD PTR FFFFFFE4[EBP], EAX
00062: 00A8 8B 45 F4    MOV     EAX, DWORD PTR FFFFFFF4[EBP]
00063: 00AB 89 45 E8    MOV     DWORD PTR FFFFFFE8[EBP], EAX
00064: 00AE BA 00000000 MOV     EDX, OFFSET .data+0000021c
00066: 00B3 8D 45 E0    LEA     EAX, DWORD PTR FFFFFFE0[EBP]
00065: 00B6 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00067: 00BB 50          PUSH    EAX
00068: 00BC 52          PUSH    EDX
00069: 00BD E8 00000000 CALL    NEAR PTR ___throw
00070: 00C2                    
00071: 00C2 83 C4 0C    ADD     ESP, 0000000C
00072: 00C5 89 75 EC    MOV     DWORD PTR FFFFFFEC[EBP], ESI
00073: 00C8     L0003
;
		if (debug) printf("Size of Memory Pool : %d bytes, ptr %p\n", mMemoryPoolSize, mMemoryPool);
00075: 00C8 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00076: 00CF 74 1C       JE      L0004
if (debug) printf("Size of Memory Pool : %d bytes, ptr %p\n", mMemoryPoolSize, mMemoryPool);
00078: 00D1 8B 83 000000E4MOV   EAX, DWORD PTR 000000E4[EBX]
00079: 00D7 50          PUSH    EAX
00080: 00D8 8B 83 000000E8MOV   EAX, DWORD PTR 000000E8[EBX]
00081: 00DE 50          PUSH    EAX
00082: 00DF 68 00000000 PUSH    OFFSET .data+00000228
00083: 00E4 FF 15 00000000 CALL DWORD PTR __imp__printf
00084: 00EA 83 C4 0C    ADD     ESP, 0000000C
00085: 00ED     L0004
printf("Size of Memory Pool : %d bytes, ptr %p\n", mMemoryPoolSize, mMemoryPool);
	
		// start sound right now
		mSoundRecord.start();
00087: 00ED             NOOP    
00088: 00ED 8D 83 0000010CLEA   EAX, DWORD PTR 0000010C[EBX]
00089: 00F3 89 C1       MOV     ECX, EAX
00090: 00F5 8B 19       MOV     EBX, DWORD PTR 00000000[ECX]
00091: 00F7 FF 53 04    CALL    DWORD PTR 00000004[EBX]
mSoundRecord.start();
	}
00093: 00FA     L0002
}

} // end of initSound for CMoteurRecord
00095: 00FA     L0000
00096: 00FA 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00097: 00FD 5E          POP     ESI
00098: 00FE 5B          POP     EBX
00099: 00FF 5D          POP     EBP
00100: 0100 C3          RETN    

Function: ?closeSound@CMoteurRecord@@IAEXXZ
} // end of initSound for CMoteurRecord


//***************************************************************************
void CMoteurRecord::closeSound(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 89 CE       MOV     ESI, ECX
{
	if (mUseSound) mSoundRecord.stop();
00008: 0007 80 BE 000000E000 CMP BYTE PTR 000000E0[ESI], 00000000
00009: 000E 74 0D       JE      L0001
if (mUseSound) mSoundRecord.stop();
00011: 0010             NOOP    
00012: 0010 8D 86 0000010CLEA   EAX, DWORD PTR 0000010C[ESI]
00013: 0016 89 C1       MOV     ECX, EAX
00014: 0018 8B 19       MOV     EBX, DWORD PTR 00000000[ECX]
00015: 001A FF 53 08    CALL    DWORD PTR 00000008[EBX]
00016: 001D     L0001
mSoundRecord.stop();

	if (mMemoryPool) delete mMemoryPool; mMemoryPool = NULL;
00018: 001D 8B 86 000000E4MOV   EAX, DWORD PTR 000000E4[ESI]
00019: 0023 09 C0       OR      EAX, EAX
00020: 0025 74 09       JE      L0002
if (mMemoryPool) delete mMemoryPool; mMemoryPool = NULL;
00022: 0027 50          PUSH    EAX
00023: 0028 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00024: 002D 83 C4 04    ADD     ESP, 00000004
00025: 0030     L0002
delete mMemoryPool; mMemoryPool = NULL;
00027: 0030 C7 86 000000E400000000 MOV DWORD PTR 000000E4[ESI], 00000000
mMemoryPool = NULL;
	mMemoryPoolSize = 0;
00029: 003A C7 86 000000E800000000 MOV DWORD PTR 000000E8[ESI], 00000000
mMemoryPoolSize = 0;

	mUseSound = true;
00031: 0044 C6 86 000000E001 MOV BYTE PTR 000000E0[ESI], 00000001
mUseSound = true;

} // end of closeSound for CMoteurRecord
00033: 004B     L0000
00034: 004B 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00035: 004E 5E          POP     ESI
00036: 004F 5B          POP     EBX
00037: 0050 5D          POP     EBP
00038: 0051 C3          RETN    

Function: ?run@CMoteurRecord@@UAEXXZ
} // end of closeSound for CMoteurRecord


//---------------------------------------------------------------------------



//***************************************************************************
void CMoteurRecord::run(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 83 EC 78    SUB     ESP, 00000078
00008: 0009 89 CB       MOV     EBX, ECX
{
ui32 msg;
ui32 msgParam;
vptr msgData;
fp64 temps, deltatemps, tempsInitial;
RSem frameRateSem;
00011: 000B 8D 45 B8    LEA     EAX, DWORD PTR FFFFFFB8[EBP]
00010: 000E 6A 01       PUSH    00000001
00012: 0010 89 C1       MOV     ECX, EAX
00013: 0012 E8 00000000 CALL    NEAR PTR ??0RSem@@QAE@I@Z
00014: 0017 83 C4 04    ADD     ESP, 00000004
RSem frameRateSem;
rbool loop = true;
00016: 001A C6 45 80 01 MOV     BYTE PTR FFFFFF80[EBP], 00000001
 loop = true;
FILE *file = NULL;
00018: 001E C7 45 C8 00000000 MOV DWORD PTR FFFFFFC8[EBP], 00000000
FILE *file = NULL;

	if (debug) printf("CMoteurRecord::run\n");
00020: 0025 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00021: 002C 74 0E       JE      L0001
if (debug) printf("CMoteurRecord::run\n");
00023: 002E 68 00000000 PUSH    OFFSET .data+00000268
00024: 0033 FF 15 00000000 CALL DWORD PTR __imp__printf
00025: 0039                    
00026: 0039 83 C4 04    ADD     ESP, 00000004
00027: 003C     L0001
printf("CMoteurRecord::run\n");
	if (debug) printf("  doc path %s\n",mDocumentPath.path());
00029: 003C 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00030: 0043 74 1D       JE      L0002
if (debug) printf("  doc path %s\n",mDocumentPath.path());
00032: 0045             NOOP    
00033: 0045 8D 83 000000B0LEA   EAX, DWORD PTR 000000B0[EBX]
00034: 004B 89 C1       MOV     ECX, EAX
00035: 004D FF 15 00000000 CALL DWORD PTR __imp_?Path@BPath@@QBEPBDXZ
00036: 0053                    
00037: 0053             NOOP    
00038: 0053             NOOP    
00039: 0053 50          PUSH    EAX
00040: 0054 68 00000000 PUSH    OFFSET .data+0000027c
00041: 0059 FF 15 00000000 CALL DWORD PTR __imp__printf
00042: 005F                    
00043: 005F 83 C4 08    ADD     ESP, 00000008
00044: 0062     L0002
printf("  doc path %s\n",mDocumentPath.path());

	frameRateSem.acquire();	// rend le semaphore bloquant
00046: 0062 83 7D C0 FF CMP     DWORD PTR FFFFFFC0[EBP], FFFFFFFF
00047: 0066 74 0D       JE      L0003
00048: 0068 8B 45 C0    MOV     EAX, DWORD PTR FFFFFFC0[EBP]
00049: 006B 50          PUSH    EAX
00050: 006C FF 15 00000000 CALL DWORD PTR __imp__acquire_sem
00051: 0072                    
00052: 0072 83 C4 04    ADD     ESP, 00000004
00053: 0075     L0003
frameRateSem.acquire();	// rend le semaphore bloquant

	try
00055: 0075     L0004
00056: 0075 89 65 E0    MOV     DWORD PTR FFFFFFE0[EBP], ESP
try
	{
		// check bitdepth
		mOldColorSpace = checkColorSpace();
00058: 0078 89 D9       MOV     ECX, EBX
00059: 007A E8 00000000 CALL    NEAR PTR ?checkColorSpace@CMoteurRecord@@AAEW4color_space@@XZ
00060: 007F                    
00061: 007F             NOOP    
00062: 007F             NOOP    
00063: 007F 89 83 00000130MOV   DWORD PTR 00000130[EBX], EAX
mOldColorSpace = checkColorSpace();
	
		// the first time, the moteur must create a display and use it
		createDisplay();
00065: 0085 89 D9       MOV     ECX, EBX
00066: 0087 E8 00000000 CALL    NEAR PTR ?createDisplay@CMoteurRecord@@IAEXXZ
00067: 008C                    
createDisplay();
	
		initFile(file);
00069: 008C 8D 45 C8    LEA     EAX, DWORD PTR FFFFFFC8[EBP]
00071: 008F 89 D9       MOV     ECX, EBX
00070: 0091 50          PUSH    EAX
00072: 0092 E8 00000000 CALL    NEAR PTR ?initFile@CMoteurRecord@@IAEXAAPAU_FILE@@@Z
00073: 0097                    
00074: 0097 83 C4 04    ADD     ESP, 00000004
initFile(file);
	
		// open sound play
		initSound();
00076: 009A 89 D9       MOV     ECX, EBX
00077: 009C E8 00000000 CALL    NEAR PTR ?initSound@CMoteurRecord@@IAEXXZ
00078: 00A1                    
initSound();

		tempsInitial = systemTime();
00080: 00A1 FF 15 00000000 CALL DWORD PTR __imp__system_time
00081: 00A7                    
00082: 00A7             NOOP    
00083: 00A7             NOOP    
00084: 00A7 52          PUSH    EDX
00085: 00A8 50          PUSH    EAX
00086: 00A9 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00087: 00AC 50          PUSH    EAX
00088: 00AD E8 00000000 CALL    NEAR PTR ___rt_s64tof64
00089: 00B2                    
00090: 00B2 83 C4 0C    ADD     ESP, 0000000C
00091: 00B5             NOOP    
00092: 00B5             NOOP    
00093: 00B5 8B 10       MOV     EDX, DWORD PTR 00000000[EAX]
00094: 00B7 89 55 B0    MOV     DWORD PTR FFFFFFB0[EBP], EDX
00095: 00BA 8B 50 04    MOV     EDX, DWORD PTR 00000004[EAX]
00096: 00BD 89 55 B4    MOV     DWORD PTR FFFFFFB4[EBP], EDX
tempsInitial = systemTime();

		while(loop)
00098: 00C0 E9 000000C9 JMP     L0005
00099: 00C5     L0006
while(loop)
		{
			temps = systemTime();
00101: 00C5 FF 15 00000000 CALL DWORD PTR __imp__system_time
00102: 00CB                    
00103: 00CB             NOOP    
00104: 00CB             NOOP    
00105: 00CB 52          PUSH    EDX
00106: 00CC 50          PUSH    EAX
00107: 00CD 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00108: 00D0 50          PUSH    EAX
00109: 00D1 E8 00000000 CALL    NEAR PTR ___rt_s64tof64
00110: 00D6                    
00111: 00D6 83 C4 0C    ADD     ESP, 0000000C
00112: 00D9             NOOP    
00113: 00D9             NOOP    
00114: 00D9 8B 10       MOV     EDX, DWORD PTR 00000000[EAX]
00126: 00DB 89 D9       MOV     ECX, EBX
00115: 00DD 89 55 A0    MOV     DWORD PTR FFFFFFA0[EBP], EDX
00116: 00E0 8B 50 04    MOV     EDX, DWORD PTR 00000004[EAX]
00117: 00E3 89 55 A4    MOV     DWORD PTR FFFFFFA4[EBP], EDX
temps = systemTime();

			//lecture message
			if (receiveMessage(msg, msgParam, msgData))
00120: 00E6 8D 45 9C    LEA     EAX, DWORD PTR FFFFFF9C[EBP]
00119: 00E9 6A 00       PUSH    00000000
00121: 00EB 50          PUSH    EAX
00122: 00EC 8D 45 98    LEA     EAX, DWORD PTR FFFFFF98[EBP]
00123: 00EF 50          PUSH    EAX
00124: 00F0 8D 45 94    LEA     EAX, DWORD PTR FFFFFF94[EBP]
00125: 00F3 50          PUSH    EAX
00127: 00F4 E8 00000000 CALL    NEAR PTR ?receiveMessage@RThread@@QAEEAAK0AAPAXPAK@Z
00128: 00F9                    
00129: 00F9 83 C4 10    ADD     ESP, 00000010
00130: 00FC             NOOP    
00131: 00FC             NOOP    
00132: 00FC 08 C0       OR      AL, AL
00133: 00FE 74 20       JE      L0007
if (receiveMessage(msg, msgParam, msgData))
			{
				// process message
				switch(msg)
00135: 0100 8B 45 94    MOV     EAX, DWORD PTR FFFFFF94[EBP]
00136: 0103 2D 52754578 SUB     EAX, 52754578
00137: 0108 74 09       JE      L0008
00138: 010A 2D FAEDFEF1 SUB     EAX, FAEDFEF1
00139: 010F 74 08       JE      L0009
00140: 0111 EB 0D       JMP     L000A
switch(msg)
				{
					case K_MSG_RTHREAD_EXIT:
00142: 0113     L0008
case K_MSG_RTHREAD_EXIT:
						loop = false;
00144: 0113 C6 45 80 00 MOV     BYTE PTR FFFFFF80[EBP], 00000000
loop = false;
						break;
00146: 0117 EB 07       JMP     L000A
break;
					case K_MSG_CHANGE_DISPLAY:
00148: 0119     L0009
case K_MSG_CHANGE_DISPLAY:
						createDisplay();
00150: 0119 89 D9       MOV     ECX, EBX
00151: 011B E8 00000000 CALL    NEAR PTR ?createDisplay@CMoteurRecord@@IAEXXZ
00152: 0120                    
createDisplay();
						break;
				}
00154: 0120     L000A
}
			}
00156: 0120     L0007
}

			// process frame
			recordFrame(file, temps);
00158: 0120 FF 75 A4    PUSH    DWORD PTR FFFFFFA4[EBP]
00159: 0123 FF 75 A0    PUSH    DWORD PTR FFFFFFA0[EBP]
00160: 0126 8B 45 C8    MOV     EAX, DWORD PTR FFFFFFC8[EBP]
00162: 0129 89 D9       MOV     ECX, EBX
00161: 012B 50          PUSH    EAX
00163: 012C E8 00000000 CALL    NEAR PTR ?recordFrame@CMoteurRecord@@IAEXPAU_FILE@@N@Z
00164: 0131                    
00165: 0131 83 C4 0C    ADD     ESP, 0000000C
recordFrame(file, temps);

			// synchronize to frame rate
			deltatemps = temps+K_FRAME_RATE-systemTime();
00167: 0134 FF 15 00000000 CALL DWORD PTR __imp__system_time
00168: 013A                    
00169: 013A             NOOP    
00170: 013A             NOOP    
00171: 013A 52          PUSH    EDX
00172: 013B 50          PUSH    EAX
00173: 013C 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00174: 013F 50          PUSH    EAX
00175: 0140 E8 00000000 CALL    NEAR PTR ___rt_s64tof64
00176: 0145                    
00177: 0145 83 C4 0C    ADD     ESP, 0000000C
00178: 0148             NOOP    
00179: 0148             NOOP    
00180: 0148 DD 00       FLD     QWORD PTR 00000000[EAX]
00181: 014A DD 45 A0    FLD     QWORD PTR FFFFFFA0[EBP]
00182: 014D DC 05 00000000 FADD QWORD PTR .data+00000290
00183: 0153 DE E1       FSUBRP  ST(1), ST
00184: 0155 DD 55 A8    FST     QWORD PTR FFFFFFA8[EBP]
deltatemps = temps+K_FRAME_RATE-systemTime();
			//printf("deltatemps %f\n", deltatemps);
			if (deltatemps > 0) frameRateSem.acquireTimeout(deltatemps);
00186: 0158 D9 EE       FLDZ    
00187: 015A DE D9       FCOMPP  ST(1), ST
00188: 015C DF E0       FSTSW   AX
00189: 015E 80 E4 05    AND     AH, 00000005
00190: 0161 80 FC 01    CMP     AH, 00000001
00191: 0164 75 28       JNE     L000B
if (deltatemps > 0) frameRateSem.acquireTimeout(deltatemps);
00195: 0166 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00193: 0169 FF 75 AC    PUSH    DWORD PTR FFFFFFAC[EBP]
00194: 016C FF 75 A8    PUSH    DWORD PTR FFFFFFA8[EBP]
00196: 016F 50          PUSH    EAX
00197: 0170 E8 00000000 CALL    NEAR PTR ___rt_f64tos64
00198: 0175                    
00199: 0175 83 C4 0C    ADD     ESP, 0000000C
00200: 0178             NOOP    
00201: 0178             NOOP    
00202: 0178 FF 70 04    PUSH    DWORD PTR 00000004[EAX]
00203: 017B FF 30       PUSH    DWORD PTR 00000000[EAX]
00204: 017D 6A 08       PUSH    00000008
00205: 017F 6A 01       PUSH    00000001
00206: 0181 8B 45 C0    MOV     EAX, DWORD PTR FFFFFFC0[EBP]
00207: 0184 50          PUSH    EAX
00208: 0185 FF 15 00000000 CALL DWORD PTR __imp__acquire_sem_etc
00209: 018B                    
00210: 018B 83 C4 14    ADD     ESP, 00000014
00211: 018E     L000B
frameRateSem.acquireTimeout(deltatemps);
		}
00213: 018E     L0005
00214: 018E 80 7D 80 00 CMP     BYTE PTR FFFFFF80[EBP], 00000000
00215: 0192 0F 85 FFFFFF2D JNE  L0006
}

		tempsInitial = (systemTime() - tempsInitial)/1e6;
00217: 0198 FF 15 00000000 CALL DWORD PTR __imp__system_time
00218: 019E                    
00219: 019E             NOOP    
00220: 019E             NOOP    
00221: 019E 52          PUSH    EDX
00222: 019F 50          PUSH    EAX
00223: 01A0 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00224: 01A3 50          PUSH    EAX
00225: 01A4 E8 00000000 CALL    NEAR PTR ___rt_s64tof64
00226: 01A9                    
00227: 01A9 83 C4 0C    ADD     ESP, 0000000C
00228: 01AC             NOOP    
00229: 01AC             NOOP    
00230: 01AC DD 00       FLD     QWORD PTR 00000000[EAX]
00231: 01AE DC 65 B0    FSUB    QWORD PTR FFFFFFB0[EBP]
00232: 01B1 DC 35 00000000 FDIV QWORD PTR .data+00000298
00233: 01B7 DD 5D B0    FSTP    QWORD PTR FFFFFFB0[EBP]
tempsInitial = (systemTime() - tempsInitial)/1e6;
		if (debug) printf("\n\nNb diff frames = %d , nb const frames = %d\n", _gDiffRec, _gConstRec);
00235: 01BA 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00236: 01C1 74 1A       JE      L000C
if (debug) printf("\n\nNb diff frames = %d , nb const frames = %d\n", _gDiffRec, _gConstRec);
00238: 01C3 A1 00000000 MOV     EAX, DWORD PTR ?_gDebug@@3_NA
00239: 01C8 50          PUSH    EAX
00240: 01C9 A1 00000000 MOV     EAX, DWORD PTR ?_gDebug@@3_NA
00241: 01CE 50          PUSH    EAX
00242: 01CF 68 00000000 PUSH    OFFSET .data+000002a0
00243: 01D4 FF 15 00000000 CALL DWORD PTR __imp__printf
00244: 01DA                    
00245: 01DA 83 C4 0C    ADD     ESP, 0000000C
00246: 01DD     L000C
printf("\n\nNb diff frames = %d , nb const frames = %d\n", _gDiffRec, _gConstRec);
		if (debug) printf("\n\nStats : %d frames, %.2f seconds, fps = %.2f\n",
00248: 01DD 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00249: 01E4 74 61       JE      L000D
if (debug) printf("\n\nStats : %d frames, %.2f seconds, fps = %.2f\n",
00251: 01E6 DD 45 B0    FLD     QWORD PTR FFFFFFB0[EBP]
00252: 01E9 DD 05 00000000 FLD  QWORD PTR .data+000002d0
00253: 01EF DE D9       FCOMPP  ST(1), ST
00254: 01F1 DF E0       FSTSW   AX
00255: 01F3 80 E4 05    AND     AH, 00000005
00256: 01F6 80 FC 01    CMP     AH, 00000001
00257: 01F9 75 1D       JNE     L000E
00258: 01FB DD 45 B0    FLD     QWORD PTR FFFFFFB0[EBP]
00259: 01FE 8B 83 000000DCMOV   EAX, DWORD PTR 000000DC[EBX]
00260: 0204 89 45 8C    MOV     DWORD PTR FFFFFF8C[EBP], EAX
00261: 0207 C7 45 90 00000000 MOV DWORD PTR FFFFFF90[EBP], 00000000
00262: 020E DF 6D 8C    FILD    QWORD PTR FFFFFF8C[EBP]
00263: 0211 DE F1       FDIVRP  ST(1), ST
00264: 0213 DD 5D EC    FSTP    QWORD PTR FFFFFFEC[EBP]
00265: 0216 EB 0E       JMP     L000F
00266: 0218     L000E
00267: 0218 C7 45 EC 00000000 MOV DWORD PTR FFFFFFEC[EBP], 00000000
00268: 021F C7 45 F0 00000000 MOV DWORD PTR FFFFFFF0[EBP], 00000000
00269: 0226     L000F
00270: 0226 FF 75 F0    PUSH    DWORD PTR FFFFFFF0[EBP]
00271: 0229 FF 75 EC    PUSH    DWORD PTR FFFFFFEC[EBP]
00272: 022C FF 75 B4    PUSH    DWORD PTR FFFFFFB4[EBP]
00273: 022F FF 75 B0    PUSH    DWORD PTR FFFFFFB0[EBP]
00274: 0232 8B 83 000000DCMOV   EAX, DWORD PTR 000000DC[EBX]
00275: 0238 50          PUSH    EAX
00276: 0239 68 00000000 PUSH    OFFSET .data+000002d8
00277: 023E FF 15 00000000 CALL DWORD PTR __imp__printf
00278: 0244                    
00279: 0244 83 C4 18    ADD     ESP, 00000018
00280: 0247     L000D
printf("\n\nStats : %d frames, %.2f seconds, fps = %.2f\n",
			mFrameCount, tempsInitial, (tempsInitial > K_EPSILON ? mFrameCount/tempsInitial : 0.0));
	
		closeSound();
00282: 0247 89 D9       MOV     ECX, EBX
00283: 0249 E8 00000000 CALL    NEAR PTR ?closeSound@CMoteurRecord@@IAEXXZ
00284: 024E                    
closeSound();
		if (file) fclose(file);
00286: 024E 83 7D C8 00 CMP     DWORD PTR FFFFFFC8[EBP], 00000000
00287: 0252 74 0D       JE      L0010
if (file) fclose(file);
00289: 0254 8B 45 C8    MOV     EAX, DWORD PTR FFFFFFC8[EBP]
00290: 0257 50          PUSH    EAX
00291: 0258 FF 15 00000000 CALL DWORD PTR __imp__fclose
00292: 025E                    
00293: 025E 83 C4 04    ADD     ESP, 00000004
00294: 0261     L0010
fclose(file);
		if (mOldColorSpace != B_NO_COLOR_SPACE)
00296: 0261 83 BB 0000013000 CMP DWORD PTR 00000130[EBX], 00000000
00297: 0268 74 11       JE      L0011
if (mOldColorSpace != B_NO_COLOR_SPACE)
		{
			// restore previous bit depth
			restoreColorSpace(mOldColorSpace);
00299: 026A 8B 83 00000130MOV   EAX, DWORD PTR 00000130[EBX]
00301: 0270 89 D9       MOV     ECX, EBX
00300: 0272 50          PUSH    EAX
00302: 0273 E8 00000000 CALL    NEAR PTR ?restoreColorSpace@CMoteurRecord@@AAEXW4color_space@@@Z
00303: 0278                    
00304: 0278 83 C4 04    ADD     ESP, 00000004
restoreColorSpace(mOldColorSpace);
		}
00306: 027B     L0011
}
		closeDisplay();
00308: 027B 89 D9       MOV     ECX, EBX
00309: 027D E8 00000000 CALL    NEAR PTR ?closeDisplay@CMoteurRecord@@IAEXXZ
00310: 0282                    
closeDisplay();

	}
00312: 0282 E9 0000008B JMP     L0012
}
	M_CATCH("Moteur Record");
00314: 0287     L0013
00315: 0287 8B 55 D8    MOV     EDX, DWORD PTR FFFFFFD8[EBP]
00316: 028A 8B 02       MOV     EAX, DWORD PTR 00000000[EDX]
00317: 028C 89 85 FFFFFF7CMOV   DWORD PTR FFFFFF7C[EBP], EAX
00318: 0292 50          PUSH    EAX
00319: 0293 68 00000000 PUSH    OFFSET .data+00000308
00320: 0298 E8 00000000 CALL    NEAR PTR ?gThrowAlertStatusT@@YAXPBDJ@Z
00321: 029D                    
00322: 029D 83 C4 08    ADD     ESP, 00000008
00323: 02A0 EB 5F       JMP     L0014
00324: 02A2     L0015
00325: 02A2 8B 55 D8    MOV     EDX, DWORD PTR FFFFFFD8[EBP]
00326: 02A5 8B 02       MOV     EAX, DWORD PTR 00000000[EDX]
00327: 02A7 89 45 84    MOV     DWORD PTR FFFFFF84[EBP], EAX
00328: 02AA 50          PUSH    EAX
00329: 02AB 68 00000000 PUSH    OFFSET .data+00000318
00330: 02B0 E8 00000000 CALL    NEAR PTR ?gThrowAlertCharPtr@@YAXPBDPAD@Z
00331: 02B5                    
00332: 02B5 83 C4 08    ADD     ESP, 00000008
00333: 02B8 EB 47       JMP     L0014
00334: 02BA     L0016
00335: 02BA 8B 45 D8    MOV     EAX, DWORD PTR FFFFFFD8[EBP]
00336: 02BD 89 45 88    MOV     DWORD PTR FFFFFF88[EBP], EAX
00337: 02C0 50          PUSH    EAX
00338: 02C1 68 00000000 PUSH    OFFSET .data+00000328
00339: 02C6 E8 00000000 CALL    NEAR PTR ?gThrowAlertRErrEx@@YAXPBDAAVRErrEx@@@Z
00340: 02CB                    
00341: 02CB 83 C4 08    ADD     ESP, 00000008
00342: 02CE EB 31       JMP     L0014
00343: 02D0     L0017
00344: 02D0 8B 45 D8    MOV     EAX, DWORD PTR FFFFFFD8[EBP]
00345: 02D3 8B 30       MOV     ESI, DWORD PTR 00000000[EAX]
00346: 02D5 56          PUSH    ESI
00347: 02D6 68 00000000 PUSH    OFFSET .data+00000338
00348: 02DB E8 00000000 CALL    NEAR PTR ?gThrowAlertRErrEx@@YAXPBDAAVRErrEx@@@Z
00349: 02E0                    
00350: 02E0 83 C4 08    ADD     ESP, 00000008
00351: 02E3 09 F6       OR      ESI, ESI
00352: 02E5 74 1A       JE      L0014
00354: 02E7 89 F1       MOV     ECX, ESI
00353: 02E9 6A 01       PUSH    00000001
00355: 02EB 8B 39       MOV     EDI, DWORD PTR 00000000[ECX]
00356: 02ED FF 17       CALL    DWORD PTR 00000000[EDI]
00357: 02EF                    
00358: 02EF 83 C4 04    ADD     ESP, 00000004
00359: 02F2     L0018
00360: 02F2 EB 0D       JMP     L0014
00361: 02F4     L0019
00362: 02F4 68 00000000 PUSH    OFFSET .data+00000348
00363: 02F9 E8 00000000 CALL    NEAR PTR ?gThrowAlertUntyped@@YAXPBD@Z
00364: 02FE                    
00365: 02FE 83 C4 04    ADD     ESP, 00000004
00366: 0301     L0014
00367: 0301 83 7D D4 00 CMP     DWORD PTR FFFFFFD4[EBP], 00000000
00368: 0305 74 08       JE      L001A
00370: 0307 8B 4D CC    MOV     ECX, DWORD PTR FFFFFFCC[EBP]
00369: 030A 6A FF       PUSH    FFFFFFFF
00371: 030C FF 55 D4    CALL    DWORD PTR FFFFFFD4[EBP]
00372: 030F                    
00373: 030F     L001A
00374: 030F 8B 65 E0    MOV     ESP, DWORD PTR FFFFFFE0[EBP]
00375: 0312     L0012
;

	// ask application to kill this thread (close this document)
	gApplication->processMessage(K_MSG_CLOSE_DOCUMENT, 0, (void *)this);
00377: 0312 6A 00       PUSH    00000000
00378: 0314 53          PUSH    EBX
00381: 0315 8B 0D 00000000 MOV  ECX, DWORD PTR ?gApplication@@3PAVCApp@@A
00379: 031B 6A 00       PUSH    00000000
00380: 031D 68 63446F63 PUSH    63446F63
00382: 0322 8B 19       MOV     EBX, DWORD PTR 00000000[ECX]
00383: 0324 FF 93 000000E8CALL  DWORD PTR 000000E8[EBX]
00384: 032A                    
00385: 032A 83 C4 10    ADD     ESP, 00000010
00386: 032D 8D 45 B8    LEA     EAX, DWORD PTR FFFFFFB8[EBP]
00387: 0330 89 C1       MOV     ECX, EAX
00388: 0332 E8 00000000 CALL    NEAR PTR ??1RSem@@UAE@XZ
00389: 0337 C7 45 C4 00000008 MOV DWORD PTR FFFFFFC4[EBP], OFFSET ??_7RInterface@@6B@+00000008
00390: 033E 8D 45 B8    LEA     EAX, DWORD PTR FFFFFFB8[EBP]
00391: 0341 05 0000000C ADD     EAX, 0000000C
gApplication->processMessage(K_MSG_CLOSE_DOCUMENT, 0, (void *)this);

} // end of run for CMoteurRecord
00393: 0346     L0000
00394: 0346 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00395: 0349 5F          POP     EDI
00396: 034A 5E          POP     ESI
00397: 034B 5B          POP     EBX
00398: 034C 5D          POP     EBP
00399: 034D C3          RETN    

Function: ?createDisplay@CMoteurRecord@@IAEXXZ
} // end of run for CMoteurRecord


//---------------------------------------------------------------------------


//***************************************************************************
void CMoteurRecord::createDisplay(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 83 EC 7C    SUB     ESP, 0000007C
00008: 0009 89 CF       MOV     EDI, ECX
{
	if (debug) printf("CMoteurRecord::createDisplay (type %d)\n", displayType());
00010: 000B 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00011: 0012 74 12       JE      L0001
if (debug) printf("CMoteurRecord::createDisplay (type %d)\n", displayType());
00013: 0014 8B 47 50    MOV     EAX, DWORD PTR 00000050[EDI]
00014: 0017 50          PUSH    EAX
00015: 0018 68 00000000 PUSH    OFFSET .data+00000358
00016: 001D FF 15 00000000 CALL DWORD PTR __imp__printf
00017: 0023 83 C4 08    ADD     ESP, 00000008
00018: 0026     L0001
printf("CMoteurRecord::createDisplay (type %d)\n", displayType());
	if (mDisplay) closeDisplay();
00020: 0026 83 7F 5C 00 CMP     DWORD PTR 0000005C[EDI], 00000000
00021: 002A 74 07       JE      L0002
if (mDisplay) closeDisplay();
00023: 002C 89 F9       MOV     ECX, EDI
00024: 002E E8 00000000 CALL    NEAR PTR ?closeDisplay@CMoteurRecord@@IAEXXZ
00025: 0033     L0002
closeDisplay();

	// reject unsupported display option
	if (displayType() != kDisplayWindow) M_THROW(kErrUnsupported);
00027: 0033 8B 47 50    MOV     EAX, DWORD PTR 00000050[EDI]
00028: 0036 09 C0       OR      EAX, EAX
00029: 0038 74 39       JE      L0003
if (displayType() != kDisplayWindow) M_THROW(kErrUnsupported);
00031: 003A 6A 0C       PUSH    0000000C
00032: 003C E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00033: 0041 83 C4 04    ADD     ESP, 00000004
00034: 0044             NOOP    
00035: 0044             NOOP    
00036: 0044             NOOP    
00037: 0044 09 C0       OR      EAX, EAX
00038: 0046 74 14       JE      L0004
00039: 0048 C7 00 00000008 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7RErrEx@@6B@+00000008
00040: 004E C7 40 04 10000006 MOV DWORD PTR 00000004[EAX], 10000006
00041: 0055 C7 40 08 00000000 MOV DWORD PTR 00000008[EAX], OFFSET .data+00000380
00042: 005C     L0004
00043: 005C 89 45 84    MOV     DWORD PTR FFFFFF84[EBP], EAX
00044: 005F BA 00000000 MOV     EDX, OFFSET .data+00000390
00046: 0064 8D 45 84    LEA     EAX, DWORD PTR FFFFFF84[EBP]
00045: 0067 6A 00       PUSH    00000000
00047: 0069 50          PUSH    EAX
00048: 006A 52          PUSH    EDX
00049: 006B E8 00000000 CALL    NEAR PTR ___throw
00050: 0070 83 C4 0C    ADD     ESP, 0000000C
00051: 0073     L0003
;

	RRect rect = RWindow::centerWindow(mDisplaySx, mDisplaySy);
00053: 0073 8B 47 58    MOV     EAX, DWORD PTR 00000058[EDI]
00054: 0076 50          PUSH    EAX
00055: 0077 8B 47 54    MOV     EAX, DWORD PTR 00000054[EDI]
00056: 007A 50          PUSH    EAX
00057: 007B 8D 45 B0    LEA     EAX, DWORD PTR FFFFFFB0[EBP]
00058: 007E 50          PUSH    EAX
00059: 007F E8 00000000 CALL    NEAR PTR ?centerWindow@RWindow@@SA?AVRRect@@KK@Z
00060: 0084 83 C4 0C    ADD     ESP, 0000000C
00061: 0087 8D 55 88    LEA     EDX, DWORD PTR FFFFFF88[EBP]
00062: 008A             NOOP    
00063: 008A             NOOP    
00064: 008A 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00065: 008D 89 42 04    MOV     DWORD PTR 00000004[EDX], EAX
00066: 0090 B8 00000008 MOV     EAX, OFFSET ??_7RInterface@@6B@+00000008
00067: 0095 89 85 FFFFFF78MOV   DWORD PTR FFFFFF78[EBP], EAX
00068: 009B 89 42 18    MOV     DWORD PTR 00000018[EDX], EAX
00069: 009E             NOOP    
00070: 009E 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00071: 00A1 BB 00000008 MOV     EBX, OFFSET ??_7RRect@@6B@+00000008
00072: 00A6 89 1A       MOV     DWORD PTR 00000000[EDX], EBX
00073: 00A8 BE 00000014 MOV     ESI, OFFSET ??_7RRect@@6B@+00000014
00074: 00AD 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00075: 00B0 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00076: 00B2 8B 45 B8    MOV     EAX, DWORD PTR FFFFFFB8[EBP]
00077: 00B5 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
00078: 00B8 8B 45 BC    MOV     EAX, DWORD PTR FFFFFFBC[EBP]
00079: 00BB 89 42 0C    MOV     DWORD PTR 0000000C[EDX], EAX
00080: 00BE 8B 45 C0    MOV     EAX, DWORD PTR FFFFFFC0[EBP]
00081: 00C1 89 42 10    MOV     DWORD PTR 00000010[EDX], EAX
00082: 00C4 8B 45 C4    MOV     EAX, DWORD PTR FFFFFFC4[EBP]
00083: 00C7 89 42 14    MOV     DWORD PTR 00000014[EDX], EAX
00084: 00CA 89 5D B0    MOV     DWORD PTR FFFFFFB0[EBP], EBX
00085: 00CD 8B 45 B4    MOV     EAX, DWORD PTR FFFFFFB4[EBP]
00086: 00D0 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00087: 00D2 8B 85 FFFFFF78MOV   EAX, DWORD PTR FFFFFF78[EBP]
00088: 00D8 89 45 C8    MOV     DWORD PTR FFFFFFC8[EBP], EAX
00089: 00DB 8D 45 B0    LEA     EAX, DWORD PTR FFFFFFB0[EBP]
00092: 00DE 8D 55 CC    LEA     EDX, DWORD PTR FFFFFFCC[EBP]
00090: 00E1 05 00000018 ADD     EAX, 00000018
RRect rect = RWindow::centerWindow(mDisplaySx, mDisplaySy);
	mDisplay = new RBlitWindow(rect, K_APP_NAME " " K_APP_VERS " Record");
00093: 00E6             NOOP    
00094: 00E6             NOOP    
00095: 00E6 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00096: 00E9 89 42 04    MOV     DWORD PTR 00000004[EDX], EAX
00097: 00EC 8B 85 FFFFFF78MOV   EAX, DWORD PTR FFFFFF78[EBP]
00098: 00F2 89 42 18    MOV     DWORD PTR 00000018[EDX], EAX
00099: 00F5             NOOP    
00100: 00F5 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00101: 00F8 89 1A       MOV     DWORD PTR 00000000[EDX], EBX
00102: 00FA 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00103: 00FD 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00104: 00FF 8B 45 90    MOV     EAX, DWORD PTR FFFFFF90[EBP]
00105: 0102 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
00106: 0105 8B 45 94    MOV     EAX, DWORD PTR FFFFFF94[EBP]
00107: 0108 89 42 0C    MOV     DWORD PTR 0000000C[EDX], EAX
00108: 010B 8B 45 98    MOV     EAX, DWORD PTR FFFFFF98[EBP]
00109: 010E 89 42 10    MOV     DWORD PTR 00000010[EDX], EAX
00110: 0111 8B 45 9C    MOV     EAX, DWORD PTR FFFFFF9C[EBP]
00111: 0114 89 42 14    MOV     DWORD PTR 00000014[EDX], EAX
00112: 0117 68 000001CC PUSH    000001CC
00113: 011C E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00114: 0121                    
00115: 0121 83 C4 04    ADD     ESP, 00000004
00116: 0124             NOOP    
00117: 0124             NOOP    
00118: 0124 89 85 FFFFFF7CMOV   DWORD PTR FFFFFF7C[EBP], EAX
00119: 012A 09 C0       OR      EAX, EAX
00120: 012C 74 1B       JE      L0005
00123: 012E 8D 45 CC    LEA     EAX, DWORD PTR FFFFFFCC[EBP]
00126: 0131 8B 8D FFFFFF7CMOV   ECX, DWORD PTR FFFFFF7C[EBP]
00121: 0137 6A 01       PUSH    00000001
00122: 0139 68 00000000 PUSH    OFFSET .data+0000039c
00124: 013E 50          PUSH    EAX
00125: 013F 6A 01       PUSH    00000001
00127: 0141 E8 00000000 CALL    NEAR PTR ??0RBlitWindow@@QAE@IVRRect@@PADE@Z
00128: 0146                    
00129: 0146 83 C4 10    ADD     ESP, 00000010
00130: 0149     L0005
00131: 0149 8B 85 FFFFFF7CMOV   EAX, DWORD PTR FFFFFF7C[EBP]
00132: 014F 89 47 5C    MOV     DWORD PTR 0000005C[EDI], EAX
00133: 0152 89 5D CC    MOV     DWORD PTR FFFFFFCC[EBP], EBX
00134: 0155 8B 45 D0    MOV     EAX, DWORD PTR FFFFFFD0[EBP]
00135: 0158 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00136: 015A 8B 85 FFFFFF78MOV   EAX, DWORD PTR FFFFFF78[EBP]
00137: 0160 89 45 E4    MOV     DWORD PTR FFFFFFE4[EBP], EAX
00138: 0163 8D 45 CC    LEA     EAX, DWORD PTR FFFFFFCC[EBP]
00139: 0166 05 00000018 ADD     EAX, 00000018
mDisplay = new RBlitWindow(rect, K_APP_NAME " " K_APP_VERS " Record");
	M_ASSERT_PTR(mDisplay);
00141: 016B 83 7F 5C 00 CMP     DWORD PTR 0000005C[EDI], 00000000
00142: 016F 75 50       JNE     L0006
00146: 0171 8D 45 E8    LEA     EAX, DWORD PTR FFFFFFE8[EBP]
00143: 0174 68 00000100 PUSH    00000100
00144: 0179 68 00000000 PUSH    OFFSET .data+000003b8
00145: 017E 68 00000000 PUSH    OFFSET .data+000003cc
00147: 0183 89 C1       MOV     ECX, EAX
00148: 0185 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00149: 018A                    
00150: 018A 83 C4 0C    ADD     ESP, 0000000C
00151: 018D B8 00000008 MOV     EAX, OFFSET ??_7RErrEx@@6B@+00000008
00152: 0192 89 45 80    MOV     DWORD PTR FFFFFF80[EBP], EAX
00153: 0195 89 45 A4    MOV     DWORD PTR FFFFFFA4[EBP], EAX
00154: 0198 8B 45 EC    MOV     EAX, DWORD PTR FFFFFFEC[EBP]
00155: 019B 89 45 A8    MOV     DWORD PTR FFFFFFA8[EBP], EAX
00156: 019E 8B 45 F0    MOV     EAX, DWORD PTR FFFFFFF0[EBP]
00157: 01A1 89 45 AC    MOV     DWORD PTR FFFFFFAC[EBP], EAX
00158: 01A4 BA 00000000 MOV     EDX, OFFSET .data+000003d8
00160: 01A9 8D 45 A4    LEA     EAX, DWORD PTR FFFFFFA4[EBP]
00159: 01AC 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00161: 01B1 50          PUSH    EAX
00162: 01B2 52          PUSH    EDX
00163: 01B3 E8 00000000 CALL    NEAR PTR ___throw
00164: 01B8                    
00165: 01B8 83 C4 0C    ADD     ESP, 0000000C
00166: 01BB 8B 45 80    MOV     EAX, DWORD PTR FFFFFF80[EBP]
00167: 01BE 89 45 E8    MOV     DWORD PTR FFFFFFE8[EBP], EAX
00168: 01C1     L0006
;
	// init and show window
	setWindow(mDisplay);
00170: 01C1 8B 47 5C    MOV     EAX, DWORD PTR 0000005C[EDI]
00171: 01C4 09 C0       OR      EAX, EAX
00172: 01C6 74 03       JE      L0007
00173: 01C8 8B 40 40    MOV     EAX, DWORD PTR 00000040[EAX]
00174: 01CB     L0007
00175: 01CB 89 47 48    MOV     DWORD PTR 00000048[EDI], EAX
setWindow(mDisplay);
	mDisplay->setQuitAppWhenWindowClosed(true);
00177: 01CE 8B 47 5C    MOV     EAX, DWORD PTR 0000005C[EDI]
00178: 01D1 8B 40 40    MOV     EAX, DWORD PTR 00000040[EAX]
00179: 01D4 C6 80 0000016C01 MOV BYTE PTR 0000016C[EAX], 00000001
mDisplay->setQuitAppWhenWindowClosed(true);
	mDisplay->setBitmapBuffer(&mOffscreen);
00181: 01DB             NOOP    
00182: 01DB 8D 47 60    LEA     EAX, DWORD PTR 00000060[EDI]
00184: 01DE 8B 4F 5C    MOV     ECX, DWORD PTR 0000005C[EDI]
00183: 01E1 50          PUSH    EAX
00185: 01E2 E8 00000000 CALL    NEAR PTR ?setBitmapBuffer@RBlitWindow@@QAEXPAU?$TRotateBuffer@PAVRBitmap@@@@@Z
00186: 01E7                    
00187: 01E7 83 C4 04    ADD     ESP, 00000004
mDisplay->setBitmapBuffer(&mOffscreen);

	// HOOK TBLD : HACK HACK !!
	// move the window _almost_ outside of the recording zone
	mDisplay->moveTo(630, 20);
00191: 01EA 8B 47 5C    MOV     EAX, DWORD PTR 0000005C[EDI]
00189: 01ED 6A 14       PUSH    00000014
00190: 01EF 68 00000276 PUSH    00000276
00192: 01F4 8B 48 40    MOV     ECX, DWORD PTR 00000040[EAX]
00193: 01F7 E8 00000000 CALL    NEAR PTR ?moveTo@RWindow@@QAEXKK@Z
00194: 01FC                    
00195: 01FC 83 C4 08    ADD     ESP, 00000008
00196: 01FF 89 5D 88    MOV     DWORD PTR FFFFFF88[EBP], EBX
00197: 0202 8B 45 8C    MOV     EAX, DWORD PTR FFFFFF8C[EBP]
00198: 0205 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00199: 0207 8B 85 FFFFFF78MOV   EAX, DWORD PTR FFFFFF78[EBP]
00200: 020D 89 45 A0    MOV     DWORD PTR FFFFFFA0[EBP], EAX
00201: 0210 8D 45 88    LEA     EAX, DWORD PTR FFFFFF88[EBP]
00202: 0213 05 00000018 ADD     EAX, 00000018
mDisplay->moveTo(630, 20);

} // end of createDisplay for CMoteurRecord
00204: 0218     L0000
00205: 0218 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00206: 021B 5F          POP     EDI
00207: 021C 5E          POP     ESI
00208: 021D 5B          POP     EBX
00209: 021E 5D          POP     EBP
00210: 021F C3          RETN    

Function: ?closeDisplay@CMoteurRecord@@IAEXXZ
} // end of createDisplay for CMoteurRecord


//***************************************************************************
void CMoteurRecord::closeDisplay(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00008: 0001 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00003: 0008 89 E5       MOV     EBP, ESP
00004: 000A 53          PUSH    EBX
00005: 000B 56          PUSH    ESI
00006: 000C 89 CE       MOV     ESI, ECX
{
	if (debug) printf("CMoteurRecord::closeDisplay\n");
00009: 000E 74 0E       JE      L0001
if (debug) printf("CMoteurRecord::closeDisplay\n");
00011: 0010 68 00000000 PUSH    OFFSET .data+000003e4
00012: 0015 FF 15 00000000 CALL DWORD PTR __imp__printf
00013: 001B 83 C4 04    ADD     ESP, 00000004
00014: 001E     L0001
printf("CMoteurRecord::closeDisplay\n");
	if (!mDisplay) return;
00016: 001E 8B 46 5C    MOV     EAX, DWORD PTR 0000005C[ESI]
00017: 0021 09 C0       OR      EAX, EAX
00018: 0023 75 07       JNE     L0002
if (!mDisplay) return;
00020: 0025 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00021: 0028 5E          POP     ESI
00022: 0029 5B          POP     EBX
00023: 002A 5D          POP     EBP
00024: 002B C3          RETN    
00025: 002C     L0002
return;
	mDisplay->deleteWindow();
00027: 002C 89 C1       MOV     ECX, EAX
00028: 002E 8B 19       MOV     EBX, DWORD PTR 00000000[ECX]
00029: 0030 FF 53 08    CALL    DWORD PTR 00000008[EBX]
mDisplay->deleteWindow();
	mDisplay = NULL;
00031: 0033 C7 46 5C 00000000 MOV DWORD PTR 0000005C[ESI], 00000000
mDisplay = NULL;
} // end of closeDisplay for CMoteurRecord
00033: 003A     L0000
00034: 003A 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00035: 003D 5E          POP     ESI
00036: 003E 5B          POP     EBX
00037: 003F 5D          POP     EBP
00038: 0040 C3          RETN    

Function: ?checkColorSpace@CMoteurRecord@@AAEW4color_space@@XZ
} // end of closeDisplay for CMoteurRecord


//---------------------------------------------------------------------------


//***************************************************************************
color_space CMoteurRecord::checkColorSpace(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 83 EC 30    SUB     ESP, 00000030
00007: 0008 89 CB       MOV     EBX, ECX
{
BRect frame;
00009: 000A D9 EE       FLDZ    
00010: 000C D9 55 D0    FST     DWORD PTR FFFFFFD0[EBP]
00011: 000F D9 5D D4    FSTP    DWORD PTR FFFFFFD4[EBP]
00012: 0012 D9 05 00000000 FLD  DWORD PTR .data+00000404
00013: 0018 D9 55 D8    FST     DWORD PTR FFFFFFD8[EBP]
00014: 001B D9 5D DC    FSTP    DWORD PTR FFFFFFDC[EBP]
BRect frame;
color_space cs;

	if(1)
	{
		BScreen screen(mScreenId);
00016: 001E FF B3 0000012CPUSH  DWORD PTR 0000012C[EBX]
00017: 0024 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00018: 0027 89 C1       MOV     ECX, EAX
00019: 0029 FF 15 00000000 CALL DWORD PTR __imp_??0BScreen@@QAE@Uscreen_id@@@Z
00020: 002F 83 C4 04    ADD     ESP, 00000004
BScreen screen(mScreenId);
		cs    = screen.ColorSpace();
00022: 0032 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00023: 0035 89 C1       MOV     ECX, EAX
00024: 0037 FF 15 00000000 CALL DWORD PTR __imp_?ColorSpace@BScreen@@QAEW4color_space@@XZ
00025: 003D                    
00026: 003D             NOOP    
00027: 003D             NOOP    
00028: 003D 89 45 E0    MOV     DWORD PTR FFFFFFE0[EBP], EAX
cs    = screen.ColorSpace();
		frame = screen.Frame();
00030: 0040 8D 45 E8    LEA     EAX, DWORD PTR FFFFFFE8[EBP]
00031: 0043 50          PUSH    EAX
00032: 0044 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00033: 0047 89 C1       MOV     ECX, EAX
00034: 0049 FF 15 00000000 CALL DWORD PTR __imp_?Frame@BScreen@@QAE?AVBRect@@XZ
00035: 004F                    
00036: 004F 83 C4 04    ADD     ESP, 00000004
00037: 0052 8B 45 E8    MOV     EAX, DWORD PTR FFFFFFE8[EBP]
00038: 0055 89 45 D0    MOV     DWORD PTR FFFFFFD0[EBP], EAX
00039: 0058 8B 45 EC    MOV     EAX, DWORD PTR FFFFFFEC[EBP]
00040: 005B 89 45 D4    MOV     DWORD PTR FFFFFFD4[EBP], EAX
00041: 005E 8B 45 F0    MOV     EAX, DWORD PTR FFFFFFF0[EBP]
00042: 0061 89 45 D8    MOV     DWORD PTR FFFFFFD8[EBP], EAX
00043: 0064 8B 45 F4    MOV     EAX, DWORD PTR FFFFFFF4[EBP]
00044: 0067 89 45 DC    MOV     DWORD PTR FFFFFFDC[EBP], EAX
00045: 006A 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00046: 006D 89 C1       MOV     ECX, EAX
00047: 006F FF 15 00000000 CALL DWORD PTR __imp_??1BScreen@@QAE@XZ
frame = screen.Frame();
	}

	if (debug) { printf("Screen : color space %04x, Frame ", (ui32)cs); frame.PrintToStream(); }
00049: 0075 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00050: 007C 74 1D       JE      L0001
if (debug) { printf("Screen : color space %04x, Frame ", (ui32)cs); frame.PrintToStream(); }
00052: 007E 8B 45 E0    MOV     EAX, DWORD PTR FFFFFFE0[EBP]
00053: 0081 50          PUSH    EAX
00054: 0082 68 00000000 PUSH    OFFSET .data+00000408
00055: 0087 FF 15 00000000 CALL DWORD PTR __imp__printf
00056: 008D 83 C4 08    ADD     ESP, 00000008
printf("Screen : color space %04x, Frame ", (ui32)cs); frame.PrintToStream(); }
00058: 0090 8D 45 D0    LEA     EAX, DWORD PTR FFFFFFD0[EBP]
00059: 0093 89 C1       MOV     ECX, EAX
00060: 0095 FF 15 00000000 CALL DWORD PTR __imp_?PrintToStream@BRect@@QBEXXZ
frame.PrintToStream(); }
00062: 009B     L0001
}

	if (cs != B_CMAP8)
00064: 009B 83 7D E0 04 CMP     DWORD PTR FFFFFFE0[EBP], 00000004
00065: 009F 0F 84 00000158 JE   L0002
if (cs != B_CMAP8)
	{
		BAlert *box;
	
		box = new BAlert(	K_APP_NAME " - About box",
00067: 00A5 68 000001A0 PUSH    000001A0
00068: 00AA E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00069: 00AF 83 C4 04    ADD     ESP, 00000004
00070: 00B2             NOOP    
00071: 00B2             NOOP    
00072: 00B2 89 C6       MOV     ESI, EAX
00073: 00B4 09 F6       OR      ESI, ESI
00074: 00B6 74 25       JE      L0003
00082: 00B8 89 F1       MOV     ECX, ESI
00075: 00BA 6A 01       PUSH    00000001
00076: 00BC 6A 01       PUSH    00000001
00077: 00BE 6A 00       PUSH    00000000
00078: 00C0 68 00000000 PUSH    OFFSET .data+0000042c
00079: 00C5 68 00000000 PUSH    OFFSET .data+00000434
00080: 00CA 68 00000000 PUSH    OFFSET .data+00000440
00081: 00CF 68 00000000 PUSH    OFFSET .data+00000550
00083: 00D4 FF 15 00000000 CALL DWORD PTR __imp_??0BAlert@@QAE@PBD0000W4button_width@@W4alert_type@@@Z
00084: 00DA                    
00085: 00DA 83 C4 1C    ADD     ESP, 0000001C
00086: 00DD     L0003
box = new BAlert(	K_APP_NAME " - About box",
											K_APP_NAME " " K_APP_VERS " for BeOS R3"
											"\nYour screen is not configured in 8-Bits/pixel "
											"color mode.\nThis parameter is set via the Screen "
											"Preference Panel.\n"
											"ScreenShooter largely better works in 8 bpp. The mode can be "
											"changed temporarily for you and set back when you'll exit the app.",
											"Change Mode", "Quit", NULL,
											B_WIDTH_FROM_WIDEST, B_INFO_ALERT);
	
		if (box && box->Go() == 0)
00088: 00DD 09 F6       OR      ESI, ESI
00089: 00DF 0F 84 00000104 JE   L0004
00090: 00E5 89 F1       MOV     ECX, ESI
00091: 00E7 FF 15 00000000 CALL DWORD PTR __imp_?Go@BAlert@@QAEJXZ
00092: 00ED             NOOP    
00093: 00ED             NOOP    
00094: 00ED 09 C0       OR      EAX, EAX
00095: 00EF 0F 85 000000F4 JNE  L0004
if (box && box->Go() == 0)
		{
			// change mode requested
			// select the appropriate constant depending on rez

			uint32 space;
			ui32 w = frame.IntegerWidth();
00099: 00F5 83 EC 08    SUB     ESP, 00000008
00097: 00F8 D9 45 D0    FLD     DWORD PTR FFFFFFD0[EBP]
00098: 00FB D8 6D D8    FSUBR   DWORD PTR FFFFFFD8[EBP]
00100: 00FE DD 1C 24    FSTP    QWORD PTR 00000000[ESP]
00101: 0101 FF 15 00000000 CALL DWORD PTR __imp__ceil
00102: 0107 83 C4 08    ADD     ESP, 00000008
00103: 010A D9 7D C8    FSTCW   WORD PTR FFFFFFC8[EBP]
00104: 010D 66 81 4D C8 0C00 OR WORD PTR FFFFFFC8[EBP], 00000C00
00105: 0113 D9 6D C8    FLDCW   WORD PTR FFFFFFC8[EBP]
00106: 0116 DB 5D C8    FISTP   DWORD PTR FFFFFFC8[EBP]
00107: 0119 8B 55 C8    MOV     EDX, DWORD PTR FFFFFFC8[EBP]
00108: 011C D9 7D C8    FSTCW   WORD PTR FFFFFFC8[EBP]
00109: 011F 66 81 65 C8 F3FF AND WORD PTR FFFFFFC8[EBP], 0000F3FF
00113: 0125 81 FA 0000063F CMP  EDX, 0000063F
00110: 012B D9 6D C8    FLDCW   WORD PTR FFFFFFC8[EBP]
00111: 012E             NOOP    
 w = frame.IntegerWidth();
			if      (w >= 1600-1)	space = B_8_BIT_1600x1200;
00114: 012E 72 07       JB      L0005
if      (w >= 1600-1)	space = B_8_BIT_1600x1200;
00116: 0130 BE 00000010 MOV     ESI, 00000010
00117: 0135 EB 41       JMP     L0006
00118: 0137     L0005
space = B_8_BIT_1600x1200;
			else if (w >= 1280-1) space = B_8_BIT_1280x1024;
00120: 0137 81 FA 000004FF CMP  EDX, 000004FF
00121: 013D 72 07       JB      L0007
if (w >= 1280-1) space = B_8_BIT_1280x1024;
00123: 013F BE 00000008 MOV     ESI, 00000008
00124: 0144 EB 32       JMP     L0008
00125: 0146     L0007
space = B_8_BIT_1280x1024;
			else if (w >= 1152-1) space = B_8_BIT_1152x900;
00127: 0146 81 FA 0000047F CMP  EDX, 0000047F
00128: 014C 72 07       JB      L0009
if (w >= 1152-1) space = B_8_BIT_1152x900;
00130: 014E BE 00008000 MOV     ESI, 00008000
00131: 0153 EB 23       JMP     L000A
00132: 0155     L0009
space = B_8_BIT_1152x900;
			else if (w >= 1024-1) space = B_8_BIT_1024x768;
00134: 0155 81 FA 000003FF CMP  EDX, 000003FF
00135: 015B 72 07       JB      L000B
if (w >= 1024-1) space = B_8_BIT_1024x768;
00137: 015D BE 00000004 MOV     ESI, 00000004
00138: 0162 EB 14       JMP     L000C
00139: 0164     L000B
space = B_8_BIT_1024x768;
			else if (w >= 800-1)  space = B_8_BIT_800x600;
00141: 0164 81 FA 0000031F CMP  EDX, 0000031F
00142: 016A 72 07       JB      L000D
if (w >= 800-1)  space = B_8_BIT_800x600;
00144: 016C BE 00000002 MOV     ESI, 00000002
00145: 0171 EB 05       JMP     L000E
00146: 0173     L000D
space = B_8_BIT_800x600;
			else 									space = B_8_BIT_640x480;
00148: 0173 BE 00000001 MOV     ESI, 00000001
00149: 0178     L000E
00150: 0178     L000C
00151: 0178     L000A
00152: 0178     L0008
00153: 0178     L0006
space = B_8_BIT_640x480;

			if (debug) printf("Screen changed to index space %08x\n", space);
00155: 0178 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00156: 017F 74 0F       JE      L000F
if (debug) printf("Screen changed to index space %08x\n", space);
00158: 0181 56          PUSH    ESI
00159: 0182 68 00000000 PUSH    OFFSET .data+0000056c
00160: 0187 FF 15 00000000 CALL DWORD PTR __imp__printf
00161: 018D 83 C4 08    ADD     ESP, 00000008
00162: 0190     L000F
printf("Screen changed to index space %08x\n", space);

			if (set_screen_space(0 /*mScreenId*/, space, false) == B_OK)
00164: 0190 6A 00       PUSH    00000000
00165: 0192 56          PUSH    ESI
00166: 0193 6A 00       PUSH    00000000
00167: 0195 FF 15 00000000 CALL DWORD PTR __imp_?set_screen_space@@YAJJK_N@Z
00168: 019B 83 C4 0C    ADD     ESP, 0000000C
00169: 019E             NOOP    
00170: 019E             NOOP    
00171: 019E 09 C0       OR      EAX, EAX
00172: 01A0 75 0A       JNE     L0010
if (set_screen_space(0 /*mScreenId*/, space, false) == B_OK)
			{
				// return and remember old color space
				return cs;
00174: 01A2 8B 45 E0    MOV     EAX, DWORD PTR FFFFFFE0[EBP]
00175: 01A5 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00176: 01A8 5E          POP     ESI
00177: 01A9 5B          POP     EBX
00178: 01AA 5D          POP     EBP
00179: 01AB C3          RETN    
return cs;
			}
00181: 01AC     L0010
}

			// failure !!
			(new BAlert("", "BeOS R3 doesn't allow programmatical change of this color space yet.",
00183: 01AC 68 000001A0 PUSH    000001A0
00184: 01B1 E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00185: 01B6 83 C4 04    ADD     ESP, 00000004
00186: 01B9             NOOP    
00187: 01B9             NOOP    
00188: 01B9 89 C6       MOV     ESI, EAX
00189: 01BB 09 F6       OR      ESI, ESI
00190: 01BD 74 22       JE      L0011
00198: 01BF 89 F1       MOV     ECX, ESI
00191: 01C1 6A 01       PUSH    00000001
00192: 01C3 6A 01       PUSH    00000001
00193: 01C5 6A 00       PUSH    00000000
00194: 01C7 6A 00       PUSH    00000000
00195: 01C9 68 00000000 PUSH    OFFSET .data+00000590
00196: 01CE 68 00000000 PUSH    OFFSET .data+00000598
00197: 01D3 68 00000000 PUSH    OFFSET .data+000005e0
00199: 01D8 FF 15 00000000 CALL DWORD PTR __imp_??0BAlert@@QAE@PBD0000W4button_width@@W4alert_type@@@Z
00200: 01DE                    
00201: 01DE 83 C4 1C    ADD     ESP, 0000001C
00202: 01E1     L0011
00203: 01E1 89 F1       MOV     ECX, ESI
00204: 01E3 FF 15 00000000 CALL DWORD PTR __imp_?Go@BAlert@@QAEJXZ
(new BAlert("", "BeOS R3 doesn't allow programmatical change of this color space yet.",
									"Quit !", NULL, NULL, B_WIDTH_FROM_WIDEST, B_INFO_ALERT))->Go();
			
		}
00206: 01E9     L0004
}

		// quit requested
		selfPostMessage(K_MSG_RTHREAD_EXIT);
00208: 01E9 6A 00       PUSH    00000000
00209: 01EB 6A 00       PUSH    00000000
00210: 01ED 6A 00       PUSH    00000000
00211: 01EF 68 52754578 PUSH    52754578
00212: 01F4 53          PUSH    EBX
00213: 01F5 E8 00000000 CALL    NEAR PTR ?postMessage@RThread@@SAXPAV1@KKPAXPAK@Z
00214: 01FA 83 C4 14    ADD     ESP, 00000014
selfPostMessage(K_MSG_RTHREAD_EXIT);
	}
00216: 01FD     L0002
}

	return B_NO_COLOR_SPACE;	// notify no change was made
00218: 01FD 31 C0       XOR     EAX, EAX
00219: 01FF     L0000
00220: 01FF 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00221: 0202 5E          POP     ESI
00222: 0203 5B          POP     EBX
00223: 0204 5D          POP     EBP
00224: 0205 C3          RETN    

Function: ?restoreColorSpace@CMoteurRecord@@AAEXW4color_space@@@Z
return B_NO_COLOR_SPACE;	// notify no change was made

} // end of checkColorSpace for CMoteurRecord


//***************************************************************************
void CMoteurRecord::restoreColorSpace(color_space cs)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00006: 0001 89 C8       MOV     EAX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
00004: 0005 53          PUSH    EBX
00005: 0006 83 EC 24    SUB     ESP, 00000024
{
BRect frame;
00008: 0009 C7 45 F4 00000000 MOV DWORD PTR FFFFFFF4[EBP], 00000000
00009: 0010 C7 45 F8 BF800000 MOV DWORD PTR FFFFFFF8[EBP], BF800000
BRect frame;

	if(1)
	{
		frame = BScreen(mScreenId).Frame();
00011: 0017 FF B0 0000012CPUSH  DWORD PTR 0000012C[EAX]
00012: 001D 8D 45 F0    LEA     EAX, DWORD PTR FFFFFFF0[EBP]
00013: 0020 89 C1       MOV     ECX, EAX
00014: 0022 FF 15 00000000 CALL DWORD PTR __imp_??0BScreen@@QAE@Uscreen_id@@@Z
00015: 0028 83 C4 04    ADD     ESP, 00000004
00016: 002B 8D 45 E0    LEA     EAX, DWORD PTR FFFFFFE0[EBP]
00017: 002E 50          PUSH    EAX
00018: 002F 8D 45 F0    LEA     EAX, DWORD PTR FFFFFFF0[EBP]
00019: 0032 89 C1       MOV     ECX, EAX
00020: 0034 FF 15 00000000 CALL DWORD PTR __imp_?Frame@BScreen@@QAE?AVBRect@@XZ
00021: 003A                    
00022: 003A 83 C4 04    ADD     ESP, 00000004
00023: 003D 8B 45 E0    MOV     EAX, DWORD PTR FFFFFFE0[EBP]
00024: 0040 89 45 F4    MOV     DWORD PTR FFFFFFF4[EBP], EAX
00025: 0043 8B 45 E8    MOV     EAX, DWORD PTR FFFFFFE8[EBP]
00026: 0046 89 45 F8    MOV     DWORD PTR FFFFFFF8[EBP], EAX
00027: 0049 8D 45 F0    LEA     EAX, DWORD PTR FFFFFFF0[EBP]
00028: 004C 89 C1       MOV     ECX, EAX
00029: 004E FF 15 00000000 CALL DWORD PTR __imp_??1BScreen@@QAE@XZ
frame = BScreen(mScreenId).Frame();
	}

	uint32 space;
	ui32 w = frame.IntegerWidth();
00033: 0054 83 EC 08    SUB     ESP, 00000008
00031: 0057 D9 45 F4    FLD     DWORD PTR FFFFFFF4[EBP]
00032: 005A D8 6D F8    FSUBR   DWORD PTR FFFFFFF8[EBP]
00034: 005D DD 1C 24    FSTP    QWORD PTR 00000000[ESP]
00035: 0060 FF 15 00000000 CALL DWORD PTR __imp__ceil
00036: 0066 83 C4 08    ADD     ESP, 00000008
00037: 0069 D9 7D D8    FSTCW   WORD PTR FFFFFFD8[EBP]
00038: 006C 66 81 4D D8 0C00 OR WORD PTR FFFFFFD8[EBP], 00000C00
00039: 0072 D9 6D D8    FLDCW   WORD PTR FFFFFFD8[EBP]
00040: 0075 DB 5D D8    FISTP   DWORD PTR FFFFFFD8[EBP]
00041: 0078 8B 55 D8    MOV     EDX, DWORD PTR FFFFFFD8[EBP]
00042: 007B D9 7D D8    FSTCW   WORD PTR FFFFFFD8[EBP]
00043: 007E 66 81 65 D8 F3FF AND WORD PTR FFFFFFD8[EBP], 0000F3FF
00047: 0084 81 FA 0000063F CMP  EDX, 0000063F
00044: 008A D9 6D D8    FLDCW   WORD PTR FFFFFFD8[EBP]
00045: 008D             NOOP    
 w = frame.IntegerWidth();
	if      (w >= 1600-1)	space = B_8_BIT_1600x1200;
00048: 008D 72 07       JB      L0001
if      (w >= 1600-1)	space = B_8_BIT_1600x1200;
00050: 008F BB 00000010 MOV     EBX, 00000010
00051: 0094 EB 41       JMP     L0002
00052: 0096     L0001
space = B_8_BIT_1600x1200;
	else if (w >= 1280-1) space = B_8_BIT_1280x1024;
00054: 0096 81 FA 000004FF CMP  EDX, 000004FF
00055: 009C 72 07       JB      L0003
if (w >= 1280-1) space = B_8_BIT_1280x1024;
00057: 009E BB 00000008 MOV     EBX, 00000008
00058: 00A3 EB 32       JMP     L0004
00059: 00A5     L0003
space = B_8_BIT_1280x1024;
	else if (w >= 1152-1) space = B_8_BIT_1152x900;
00061: 00A5 81 FA 0000047F CMP  EDX, 0000047F
00062: 00AB 72 07       JB      L0005
if (w >= 1152-1) space = B_8_BIT_1152x900;
00064: 00AD BB 00008000 MOV     EBX, 00008000
00065: 00B2 EB 23       JMP     L0006
00066: 00B4     L0005
space = B_8_BIT_1152x900;
	else if (w >= 1024-1) space = B_8_BIT_1024x768;
00068: 00B4 81 FA 000003FF CMP  EDX, 000003FF
00069: 00BA 72 07       JB      L0007
if (w >= 1024-1) space = B_8_BIT_1024x768;
00071: 00BC BB 00000004 MOV     EBX, 00000004
00072: 00C1 EB 14       JMP     L0008
00073: 00C3     L0007
space = B_8_BIT_1024x768;
	else if (w >= 800-1)  space = B_8_BIT_800x600;
00075: 00C3 81 FA 0000031F CMP  EDX, 0000031F
00076: 00C9 72 07       JB      L0009
if (w >= 800-1)  space = B_8_BIT_800x600;
00078: 00CB BB 00000002 MOV     EBX, 00000002
00079: 00D0 EB 05       JMP     L000A
00080: 00D2     L0009
space = B_8_BIT_800x600;
	else 									space = B_8_BIT_640x480;
00082: 00D2 BB 00000001 MOV     EBX, 00000001
00083: 00D7     L000A
00084: 00D7     L0008
00085: 00D7     L0006
00086: 00D7     L0004
00087: 00D7     L0002
space = B_8_BIT_640x480;

	if (space == B_8_BIT_1152x900)
00089: 00D7 81 FB 00008000 CMP  EBX, 00008000
00090: 00DD 75 17       JNE     L000B
if (space == B_8_BIT_1152x900)
		switch(cs)
00092: 00DF 8B 45 08    MOV     EAX, DWORD PTR 00000008[EBP]
00093: 00E2 2D 00000005 SUB     EAX, 00000005
00094: 00E7 74 07       JE      L000C
00095: 00E9 2D 00000003 SUB     EAX, 00000003
00096: 00EE 74 00       JE      L000C
switch(cs)
		{
			case B_RGB16: space = B_16_BIT_1152x900;
00098: 00F0     L000C
case B_RGB16: space = B_16_BIT_1152x900;
			case B_RGB32: space = B_32_BIT_1152x900;
00100: 00F0     L000E
case B_RGB32: space = B_32_BIT_1152x900;
			default : return;
00102: 00F0     L000D
default : return;
00104: 00F0 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00105: 00F3 5B          POP     EBX
00106: 00F4 5D          POP     EBP
00107: 00F5 C3          RETN    
return;
		}
00109: 00F6     L000B
}
	else switch(cs)
00111: 00F6 8B 45 08    MOV     EAX, DWORD PTR 00000008[EBP]
00112: 00F9 2D 00000005 SUB     EAX, 00000005
00113: 00FE 3D 0000000B CMP     EAX, 0000000B
00114: 0103 77 58       JA      L000F
00115: 0105 FF 24 85 0000010C JMP L0010[EAX*4]
00116: 010C     L0010
00117: 010C 00000148    .dd     L0011
00118: 0110 0000015D    .dd     L000F
00119: 0114 0000015D    .dd     L000F
00120: 0118 00000151    .dd     L0012
00121: 011C 0000015D    .dd     L000F
00122: 0120 0000015D    .dd     L000F
00123: 0124 0000015D    .dd     L000F
00124: 0128 0000015D    .dd     L000F
00125: 012C 0000015D    .dd     L000F
00126: 0130 0000015D    .dd     L000F
00127: 0134 0000015D    .dd     L000F
00128: 0138 0000013C    .dd     L0013
switch(cs)
	{
		case B_RGB15: space *= B_15_BIT_640x480; break;
00130: 013C     L0013
case B_RGB15: space *= B_15_BIT_640x480; break;
00132: 013C 89 D8       MOV     EAX, EBX
00133: 013E 69 C0 00040000 IMUL EAX, 00040000
00134: 0144 89 C3       MOV     EBX, EAX
space *= B_15_BIT_640x480; break;
00136: 0146 EB 1B       JMP     L0014
break;
		case B_RGB16: space *= B_16_BIT_640x480; break;
00138: 0148     L0011
case B_RGB16: space *= B_16_BIT_640x480; break;
00140: 0148 89 D8       MOV     EAX, EBX
00141: 014A 6B C0 20    IMUL    EAX, 00000020
00142: 014D 89 C3       MOV     EBX, EAX
space *= B_16_BIT_640x480; break;
00144: 014F EB 12       JMP     L0014
break;
		case B_RGB32: space *= B_32_BIT_640x480; break;
00146: 0151     L0012
case B_RGB32: space *= B_32_BIT_640x480; break;
00148: 0151 89 D8       MOV     EAX, EBX
00149: 0153 69 C0 00000400 IMUL EAX, 00000400
00150: 0159 89 C3       MOV     EBX, EAX
space *= B_32_BIT_640x480; break;
00152: 015B EB 06       JMP     L0014
break;
		default: return;
00154: 015D     L000F
default: return;
00156: 015D 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00157: 0160 5B          POP     EBX
00158: 0161 5D          POP     EBP
00159: 0162 C3          RETN    
return;
	}
00161: 0163     L0014
}

	if (debug) printf("Screen restored to index space %08x\n", space);
00163: 0163 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00164: 016A 74 0F       JE      L0015
if (debug) printf("Screen restored to index space %08x\n", space);
00166: 016C 53          PUSH    EBX
00167: 016D 68 00000000 PUSH    OFFSET .data+000005e4
00168: 0172 FF 15 00000000 CALL DWORD PTR __imp__printf
00169: 0178 83 C4 08    ADD     ESP, 00000008
00170: 017B     L0015
printf("Screen restored to index space %08x\n", space);

	set_screen_space(0 /*mScreenId*/, space, false);
00172: 017B 6A 00       PUSH    00000000
00173: 017D 53          PUSH    EBX
00174: 017E 6A 00       PUSH    00000000
00175: 0180 FF 15 00000000 CALL DWORD PTR __imp_?set_screen_space@@YAJJK_N@Z
00176: 0186 83 C4 0C    ADD     ESP, 0000000C
set_screen_space(0 /*mScreenId*/, space, false);

} // end of restoreColorSpace for CMoteurRecord
00178: 0189     L0000
00179: 0189 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00180: 018C 5B          POP     EBX
00181: 018D 5D          POP     EBP
00182: 018E C3          RETN    

Function: ?displayFrame@CMoteurRecord@@IAEXXZ
} // end of restoreColorSpace for CMoteurRecord


//---------------------------------------------------------------------------


//***************************************************************************
void CMoteurRecord::displayFrame(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 81 EC 000000B0 SUB  ESP, 000000B0
00008: 000C 89 CF       MOV     EDI, ECX
{
RBitmap *offscreen;

	offscreen = mOffscreen.acquireWrite();
00010: 000E             NOOP    
00011: 000E 8D 5F 60    LEA     EBX, DWORD PTR 00000060[EDI]
00012: 0011 83 C3 24    ADD     EBX, 00000024
00013: 0014             NOOP    
00014: 0014 89 D9       MOV     ECX, EBX
00015: 0016 E8 00000000 CALL    NEAR PTR ?acquire@RSem@@QAEXXZ
00016: 001B 8B 87 00000080MOV   EAX, DWORD PTR 00000080[EDI]
00017: 0021             NOOP    
00018: 0021 50          PUSH    EAX
00019: 0022             NOOP    
00020: 0022 8D 47 60    LEA     EAX, DWORD PTR 00000060[EDI]
00021: 0025 05 00000008 ADD     EAX, 00000008
00022: 002A 89 C1       MOV     ECX, EAX
00023: 002C E8 00000000 CALL    NEAR PTR ?itemAt@?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@QAEPAU?$SRotateItem@PAVRBitmap@@@@J@Z
00024: 0031 83 C4 04    ADD     ESP, 00000004
00025: 0034             NOOP    
00026: 0034             NOOP    
00027: 0034 89 C6       MOV     ESI, EAX
00028: 0036 89 D9       MOV     ECX, EBX
00029: 0038 E8 00000000 CALL    NEAR PTR ?release@RSem@@QAEXXZ
00030: 003D 8B 06       MOV     EAX, DWORD PTR 00000000[ESI]
00031: 003F 89 85 FFFFFF48MOV   DWORD PTR FFFFFF48[EBP], EAX
00032: 0045             NOOP    
offscreen = mOffscreen.acquireWrite();
	M_ASSERT_PTR(offscreen);
00034: 0045 83 BD FFFFFF4800 CMP DWORD PTR FFFFFF48[EBP], 00000000
00035: 004C 75 56       JNE     L0001
00039: 004E 8D 45 94    LEA     EAX, DWORD PTR FFFFFF94[EBP]
00036: 0051 68 00000192 PUSH    00000192
00037: 0056 68 00000000 PUSH    OFFSET .data+0000060c
00038: 005B 68 00000000 PUSH    OFFSET .data+00000620
00040: 0060 89 C1       MOV     ECX, EAX
00041: 0062 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00042: 0067 83 C4 0C    ADD     ESP, 0000000C
00043: 006A BB 00000008 MOV     EBX, OFFSET ??_7RErrEx@@6B@+00000008
00044: 006F 89 9D FFFFFF50MOV   DWORD PTR FFFFFF50[EBP], EBX
00045: 0075 8B 45 98    MOV     EAX, DWORD PTR FFFFFF98[EBP]
00046: 0078 89 85 FFFFFF54MOV   DWORD PTR FFFFFF54[EBP], EAX
00047: 007E 8B 45 9C    MOV     EAX, DWORD PTR FFFFFF9C[EBP]
00048: 0081 89 85 FFFFFF58MOV   DWORD PTR FFFFFF58[EBP], EAX
00049: 0087 BA 00000000 MOV     EDX, OFFSET .data+0000062c
00051: 008C 8D 85 FFFFFF50LEA   EAX, DWORD PTR FFFFFF50[EBP]
00050: 0092 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00052: 0097 50          PUSH    EAX
00053: 0098 52          PUSH    EDX
00054: 0099 E8 00000000 CALL    NEAR PTR ___throw
00055: 009E                    
00056: 009E 83 C4 0C    ADD     ESP, 0000000C
00057: 00A1 89 5D 94    MOV     DWORD PTR FFFFFF94[EBP], EBX
00058: 00A4     L0001
;

	RBitmap *src = mCurrentImg;
00060: 00A4 8B 87 00000098MOV   EAX, DWORD PTR 00000098[EDI]
00061: 00AA 89 85 FFFFFF4CMOV   DWORD PTR FFFFFF4C[EBP], EAX
RBitmap *src = mCurrentImg;
	RRect srcRect = src->bounds();
00063: 00B0 8D 45 A0    LEA     EAX, DWORD PTR FFFFFFA0[EBP]
00065: 00B3 8B 8D FFFFFF4CMOV   ECX, DWORD PTR FFFFFF4C[EBP]
00064: 00B9 50          PUSH    EAX
00066: 00BA E8 00000000 CALL    NEAR PTR ?bounds@RBitmap@@QAE?AVRRect@@XZ
00067: 00BF 83 C4 04    ADD     ESP, 00000004
00068: 00C2 8D 95 FFFFFF5CLEA   EDX, DWORD PTR FFFFFF5C[EBP]
00069: 00C8             NOOP    
00070: 00C8             NOOP    
00071: 00C8 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00072: 00CB 89 42 04    MOV     DWORD PTR 00000004[EDX], EAX
00073: 00CE B8 00000008 MOV     EAX, OFFSET ??_7RInterface@@6B@+00000008
00074: 00D3 89 85 FFFFFF44MOV   DWORD PTR FFFFFF44[EBP], EAX
00075: 00D9 89 42 18    MOV     DWORD PTR 00000018[EDX], EAX
00076: 00DC             NOOP    
00077: 00DC 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00078: 00DF BB 00000008 MOV     EBX, OFFSET ??_7RRect@@6B@+00000008
00079: 00E4 89 1A       MOV     DWORD PTR 00000000[EDX], EBX
00080: 00E6 BE 00000014 MOV     ESI, OFFSET ??_7RRect@@6B@+00000014
00081: 00EB 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00082: 00EE 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00083: 00F0 8B 45 A8    MOV     EAX, DWORD PTR FFFFFFA8[EBP]
00084: 00F3 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
00085: 00F6 8B 45 AC    MOV     EAX, DWORD PTR FFFFFFAC[EBP]
00086: 00F9 89 42 0C    MOV     DWORD PTR 0000000C[EDX], EAX
00087: 00FC 8B 45 B0    MOV     EAX, DWORD PTR FFFFFFB0[EBP]
00088: 00FF 89 42 10    MOV     DWORD PTR 00000010[EDX], EAX
00089: 0102 8B 45 B4    MOV     EAX, DWORD PTR FFFFFFB4[EBP]
00090: 0105 89 42 14    MOV     DWORD PTR 00000014[EDX], EAX
00091: 0108 89 5D A0    MOV     DWORD PTR FFFFFFA0[EBP], EBX
00092: 010B 8B 45 A4    MOV     EAX, DWORD PTR FFFFFFA4[EBP]
00093: 010E 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00094: 0110 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00095: 0116 89 45 B8    MOV     DWORD PTR FFFFFFB8[EBP], EAX
00096: 0119 8D 45 A0    LEA     EAX, DWORD PTR FFFFFFA0[EBP]
00099: 011C 8D 95 FFFFFF78LEA   EDX, DWORD PTR FFFFFF78[EBP]
00097: 0122 05 00000018 ADD     EAX, 00000018
RRect srcRect = src->bounds();
	RRect destRect(srcRect);
00100: 0127             NOOP    
00101: 0127             NOOP    
00102: 0127 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00103: 012A 89 42 04    MOV     DWORD PTR 00000004[EDX], EAX
00104: 012D 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00105: 0133 89 42 18    MOV     DWORD PTR 00000018[EDX], EAX
00106: 0136             NOOP    
00107: 0136 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00108: 0139 89 1A       MOV     DWORD PTR 00000000[EDX], EBX
00109: 013B 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00110: 013E 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00111: 0140 8B 85 FFFFFF64MOV   EAX, DWORD PTR FFFFFF64[EBP]
00112: 0146 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
00113: 0149 8B 85 FFFFFF68MOV   EAX, DWORD PTR FFFFFF68[EBP]
00114: 014F 89 42 0C    MOV     DWORD PTR 0000000C[EDX], EAX
00115: 0152 8B 85 FFFFFF6CMOV   EAX, DWORD PTR FFFFFF6C[EBP]
00116: 0158 89 42 10    MOV     DWORD PTR 00000010[EDX], EAX
00117: 015B 8B 85 FFFFFF70MOV   EAX, DWORD PTR FFFFFF70[EBP]
00118: 0161 89 42 14    MOV     DWORD PTR 00000014[EDX], EAX
RRect destRect(srcRect);
	offscreen->add(*src, srcRect, destRect);
00120: 0164 8D 55 BC    LEA     EDX, DWORD PTR FFFFFFBC[EBP]
00121: 0167             NOOP    
00122: 0167             NOOP    
00123: 0167 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00124: 016A 89 42 04    MOV     DWORD PTR 00000004[EDX], EAX
00125: 016D 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00126: 0173 89 42 18    MOV     DWORD PTR 00000018[EDX], EAX
00127: 0176             NOOP    
00128: 0176 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00129: 0179 89 1A       MOV     DWORD PTR 00000000[EDX], EBX
00130: 017B 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00131: 017E 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00132: 0180 8B 85 FFFFFF64MOV   EAX, DWORD PTR FFFFFF64[EBP]
00133: 0186 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
00134: 0189 8B 85 FFFFFF68MOV   EAX, DWORD PTR FFFFFF68[EBP]
00135: 018F 89 42 0C    MOV     DWORD PTR 0000000C[EDX], EAX
00136: 0192 8B 85 FFFFFF6CMOV   EAX, DWORD PTR FFFFFF6C[EBP]
00137: 0198 89 42 10    MOV     DWORD PTR 00000010[EDX], EAX
00138: 019B 8B 85 FFFFFF70MOV   EAX, DWORD PTR FFFFFF70[EBP]
00139: 01A1 89 42 14    MOV     DWORD PTR 00000014[EDX], EAX
00140: 01A4 8D 55 D8    LEA     EDX, DWORD PTR FFFFFFD8[EBP]
00141: 01A7             NOOP    
00142: 01A7             NOOP    
00143: 01A7 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00144: 01AA 89 42 04    MOV     DWORD PTR 00000004[EDX], EAX
00145: 01AD 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00146: 01B3 89 42 18    MOV     DWORD PTR 00000018[EDX], EAX
00147: 01B6             NOOP    
00148: 01B6 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00149: 01B9 89 1A       MOV     DWORD PTR 00000000[EDX], EBX
00150: 01BB 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00151: 01BE 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00152: 01C0 8B 45 80    MOV     EAX, DWORD PTR FFFFFF80[EBP]
00153: 01C3 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
00154: 01C6 8B 45 84    MOV     EAX, DWORD PTR FFFFFF84[EBP]
00155: 01C9 89 42 0C    MOV     DWORD PTR 0000000C[EDX], EAX
00156: 01CC 8B 45 88    MOV     EAX, DWORD PTR FFFFFF88[EBP]
00157: 01CF 89 42 10    MOV     DWORD PTR 00000010[EDX], EAX
00158: 01D2 8B 45 8C    MOV     EAX, DWORD PTR FFFFFF8C[EBP]
00159: 01D5 89 42 14    MOV     DWORD PTR 00000014[EDX], EAX
00160: 01D8 8D 45 D8    LEA     EAX, DWORD PTR FFFFFFD8[EBP]
00165: 01DB 8B 8D FFFFFF48MOV   ECX, DWORD PTR FFFFFF48[EBP]
00161: 01E1 50          PUSH    EAX
00162: 01E2 8D 45 BC    LEA     EAX, DWORD PTR FFFFFFBC[EBP]
00163: 01E5 50          PUSH    EAX
00164: 01E6 FF B5 FFFFFF4CPUSH  DWORD PTR FFFFFF4C[EBP]
00166: 01EC E8 00000000 CALL    NEAR PTR ?add@RBitmap@@QAEXAAV1@VRRect@@V2@@Z
00167: 01F1                    
00168: 01F1 83 C4 0C    ADD     ESP, 0000000C
00169: 01F4 89 5D D8    MOV     DWORD PTR FFFFFFD8[EBP], EBX
00170: 01F7 8B 45 DC    MOV     EAX, DWORD PTR FFFFFFDC[EBP]
00171: 01FA 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00172: 01FC 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00173: 0202 89 45 F0    MOV     DWORD PTR FFFFFFF0[EBP], EAX
00174: 0205 8D 45 D8    LEA     EAX, DWORD PTR FFFFFFD8[EBP]
00176: 0208 89 5D BC    MOV     DWORD PTR FFFFFFBC[EBP], EBX
00175: 020B 05 00000018 ADD     EAX, 00000018
00177: 0210 8B 45 C0    MOV     EAX, DWORD PTR FFFFFFC0[EBP]
00178: 0213 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00179: 0215 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00180: 021B 89 45 D4    MOV     DWORD PTR FFFFFFD4[EBP], EAX
00181: 021E 8D 45 BC    LEA     EAX, DWORD PTR FFFFFFBC[EBP]
00182: 0221 05 00000018 ADD     EAX, 00000018
offscreen->add(*src, srcRect, destRect);

	mOffscreen.releaseWrite();
00184: 0226 83 BF 0000008CFF CMP DWORD PTR 0000008C[EDI], FFFFFFFF
00185: 022D 74 10       JE      L0002
00186: 022F 8B 87 0000008CMOV   EAX, DWORD PTR 0000008C[EDI]
00187: 0235 50          PUSH    EAX
00188: 0236 FF 15 00000000 CALL DWORD PTR __imp__acquire_sem
00189: 023C                    
00190: 023C 83 C4 04    ADD     ESP, 00000004
00191: 023F     L0002
00192: 023F 8B 47 7C    MOV     EAX, DWORD PTR 0000007C[EDI]
00193: 0242 8B 57 78    MOV     EDX, DWORD PTR 00000078[EDI]
00194: 0245 09 D2       OR      EDX, EDX
00195: 0247 74 0A       JE      L0003
00196: 0249 3B 47 70    CMP     EAX, DWORD PTR 00000070[EDI]
00197: 024C 7D 05       JGE     L0003
00198: 024E 8B 04 82    MOV     EAX, DWORD PTR 00000000[EDX][EAX*4]
00199: 0251 EB 02       JMP     L0004
00200: 0253     L0003
00201: 0253 31 C0       XOR     EAX, EAX
00202: 0255     L0004
00203: 0255 C7 40 04 00000003 MOV DWORD PTR 00000004[EAX], 00000003
00204: 025C 83 BF 0000008CFF CMP DWORD PTR 0000008C[EDI], FFFFFFFF
00205: 0263 74 10       JE      L0005
00206: 0265 8B 87 0000008CMOV   EAX, DWORD PTR 0000008C[EDI]
00207: 026B 50          PUSH    EAX
00208: 026C FF 15 00000000 CALL DWORD PTR __imp__release_sem
00209: 0272                    
00210: 0272 83 C4 04    ADD     ESP, 00000004
00211: 0275     L0005
00212: 0275 89 9D FFFFFF78MOV   DWORD PTR FFFFFF78[EBP], EBX
00213: 027B 8B 85 FFFFFF7CMOV   EAX, DWORD PTR FFFFFF7C[EBP]
00214: 0281 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00215: 0283 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00216: 0289 89 45 90    MOV     DWORD PTR FFFFFF90[EBP], EAX
00217: 028C 8D 85 FFFFFF78LEA   EAX, DWORD PTR FFFFFF78[EBP]
00219: 0292 89 9D FFFFFF5CMOV   DWORD PTR FFFFFF5C[EBP], EBX
00218: 0298 05 00000018 ADD     EAX, 00000018
00220: 029D 8B 85 FFFFFF60MOV   EAX, DWORD PTR FFFFFF60[EBP]
00221: 02A3 89 30       MOV     DWORD PTR 00000000[EAX], ESI
00222: 02A5 8B 85 FFFFFF44MOV   EAX, DWORD PTR FFFFFF44[EBP]
00223: 02AB 89 85 FFFFFF74MOV   DWORD PTR FFFFFF74[EBP], EAX
00224: 02B1 8D 85 FFFFFF5CLEA   EAX, DWORD PTR FFFFFF5C[EBP]
00225: 02B7 05 00000018 ADD     EAX, 00000018
mOffscreen.releaseWrite();

} // end of displayFrame for CMoteurRecord
00227: 02BC     L0000
00228: 02BC 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00229: 02BF 5F          POP     EDI
00230: 02C0 5E          POP     ESI
00231: 02C1 5B          POP     EBX
00232: 02C2 5D          POP     EBP
00233: 02C3 C3          RETN    

Function: ?f_bg_write2@CMoteurRecord@@IAEEKPAU_FILE@@@Z
} // end of displayFrame for CMoteurRecord


//---------------------------------------------------------------------------


//***************************************************************************
rbool CMoteurRecord::f_bg_write2(ui32 s, FILE *f)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 83 EC 08    SUB     ESP, 00000008
00007: 0008 8B 55 08    MOV     EDX, DWORD PTR 00000008[EBP]
00008: 000B 8B 75 0C    MOV     ESI, DWORD PTR 0000000C[EBP]
00009: 000E 89 4D F2    MOV     DWORD PTR FFFFFFF2[EBP], ECX
{
ui8 a,b;
	a=s;
00011: 0011 88 55 F6    MOV     BYTE PTR FFFFFFF6[EBP], DL
a=s;
	b=s>>8;
00013: 0014 89 D0       MOV     EAX, EDX
00014: 0016 C1 E8 08    SHR     EAX, 00000008
00017: 0019 31 DB       XOR     EBX, EBX
00015: 001B 88 45 F7    MOV     BYTE PTR FFFFFFF7[EBP], AL
b=s>>8;
	return fwrite(&b, 1, 1, f) && fwrite(&a, 1, 1, f);
00018: 001E 56          PUSH    ESI
00021: 001F 8D 45 F7    LEA     EAX, DWORD PTR FFFFFFF7[EBP]
00019: 0022 6A 01       PUSH    00000001
00020: 0024 6A 01       PUSH    00000001
00022: 0026 50          PUSH    EAX
00023: 0027 FF 15 00000000 CALL DWORD PTR __imp__fwrite
00024: 002D 83 C4 10    ADD     ESP, 00000010
00025: 0030             NOOP    
00026: 0030             NOOP    
00027: 0030 09 C0       OR      EAX, EAX
00028: 0032 74 18       JE      L0001
00029: 0034 56          PUSH    ESI
00032: 0035 8D 45 F6    LEA     EAX, DWORD PTR FFFFFFF6[EBP]
00030: 0038 6A 01       PUSH    00000001
00031: 003A 6A 01       PUSH    00000001
00033: 003C 50          PUSH    EAX
00034: 003D FF 15 00000000 CALL DWORD PTR __imp__fwrite
00035: 0043 83 C4 10    ADD     ESP, 00000010
00036: 0046             NOOP    
00037: 0046             NOOP    
00038: 0046 09 C0       OR      EAX, EAX
00039: 0048 74 02       JE      L0001
00040: 004A B3 01       MOV     BL, 00000001
00041: 004C     L0001
00042: 004C 88 D8       MOV     AL, BL
00043: 004E     L0000
00044: 004E 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00045: 0051 5E          POP     ESI
00046: 0052 5B          POP     EBX
00047: 0053 5D          POP     EBP
00048: 0054 C3          RETN    

Function: ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
return fwrite(&b, 1, 1, f) && fwrite(&a, 1, 1, f);
}

//***************************************************************************
rbool CMoteurRecord::f_bg_write4(ui32 s, FILE *f)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 83 EC 10    SUB     ESP, 00000010
00007: 0008 8B 55 08    MOV     EDX, DWORD PTR 00000008[EBP]
00008: 000B 8B 75 0C    MOV     ESI, DWORD PTR 0000000C[EBP]
00009: 000E 89 4D F0    MOV     DWORD PTR FFFFFFF0[EBP], ECX
{
ui8 a,b,c,d;
	a=s;
00011: 0011 88 55 F4    MOV     BYTE PTR FFFFFFF4[EBP], DL
a=s;
	b=s>>8;
00013: 0014 89 D0       MOV     EAX, EDX
00014: 0016 C1 E8 08    SHR     EAX, 00000008
00015: 0019 88 45 F5    MOV     BYTE PTR FFFFFFF5[EBP], AL
b=s>>8;
	c=s>>16;
00017: 001C 89 D0       MOV     EAX, EDX
00018: 001E C1 E8 10    SHR     EAX, 00000010
00019: 0021 88 45 F6    MOV     BYTE PTR FFFFFFF6[EBP], AL
c=s>>16;
	d=s>>24;
00021: 0024 89 D0       MOV     EAX, EDX
00022: 0026 C1 E8 18    SHR     EAX, 00000018
00027: 0029 31 DB       XOR     EBX, EBX
00023: 002B 88 45 F7    MOV     BYTE PTR FFFFFFF7[EBP], AL
d=s>>24;
	return fwrite(&d, 1, 1, f) && fwrite(&c, 1, 1, f) && fwrite(&b, 1, 1, f) && fwrite(&a, 1, 1, f);
00025: 002E C6 45 EC 00 MOV     BYTE PTR FFFFFFEC[EBP], 00000000
00026: 0032 C6 45 E8 00 MOV     BYTE PTR FFFFFFE8[EBP], 00000000
00028: 0036 56          PUSH    ESI
00031: 0037 8D 45 F7    LEA     EAX, DWORD PTR FFFFFFF7[EBP]
00029: 003A 6A 01       PUSH    00000001
00030: 003C 6A 01       PUSH    00000001
00032: 003E 50          PUSH    EAX
00033: 003F FF 15 00000000 CALL DWORD PTR __imp__fwrite
00034: 0045 83 C4 10    ADD     ESP, 00000010
00035: 0048             NOOP    
00036: 0048             NOOP    
00037: 0048 09 C0       OR      EAX, EAX
00038: 004A 74 18       JE      L0001
00039: 004C 56          PUSH    ESI
00042: 004D 8D 45 F6    LEA     EAX, DWORD PTR FFFFFFF6[EBP]
00040: 0050 6A 01       PUSH    00000001
00041: 0052 6A 01       PUSH    00000001
00043: 0054 50          PUSH    EAX
00044: 0055 FF 15 00000000 CALL DWORD PTR __imp__fwrite
00045: 005B 83 C4 10    ADD     ESP, 00000010
00046: 005E             NOOP    
00047: 005E             NOOP    
00048: 005E 09 C0       OR      EAX, EAX
00049: 0060 74 02       JE      L0001
00050: 0062 B3 01       MOV     BL, 00000001
00051: 0064     L0001
00052: 0064 08 DB       OR      BL, BL
00053: 0066 74 1A       JE      L0002
00054: 0068 56          PUSH    ESI
00057: 0069 8D 45 F5    LEA     EAX, DWORD PTR FFFFFFF5[EBP]
00055: 006C 6A 01       PUSH    00000001
00056: 006E 6A 01       PUSH    00000001
00058: 0070 50          PUSH    EAX
00059: 0071 FF 15 00000000 CALL DWORD PTR __imp__fwrite
00060: 0077 83 C4 10    ADD     ESP, 00000010
00061: 007A             NOOP    
00062: 007A             NOOP    
00063: 007A 09 C0       OR      EAX, EAX
00064: 007C 74 04       JE      L0002
00065: 007E C6 45 E8 01 MOV     BYTE PTR FFFFFFE8[EBP], 00000001
00066: 0082     L0002
00067: 0082 80 7D E8 00 CMP     BYTE PTR FFFFFFE8[EBP], 00000000
00068: 0086 74 1A       JE      L0003
00069: 0088 56          PUSH    ESI
00072: 0089 8D 45 F4    LEA     EAX, DWORD PTR FFFFFFF4[EBP]
00070: 008C 6A 01       PUSH    00000001
00071: 008E 6A 01       PUSH    00000001
00073: 0090 50          PUSH    EAX
00074: 0091 FF 15 00000000 CALL DWORD PTR __imp__fwrite
00075: 0097 83 C4 10    ADD     ESP, 00000010
00076: 009A             NOOP    
00077: 009A             NOOP    
00078: 009A 09 C0       OR      EAX, EAX
00079: 009C 74 04       JE      L0003
00080: 009E C6 45 EC 01 MOV     BYTE PTR FFFFFFEC[EBP], 00000001
00081: 00A2     L0003
00082: 00A2 8A 45 EC    MOV     AL, BYTE PTR FFFFFFEC[EBP]
00083: 00A5     L0000
00084: 00A5 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00085: 00A8 5E          POP     ESI
00086: 00A9 5B          POP     EBX
00087: 00AA 5D          POP     EBP
00088: 00AB C3          RETN    

Function: ?recordFrame@CMoteurRecord@@IAEXPAU_FILE@@N@Z
return fwrite(&d, 1, 1, f) && fwrite(&c, 1, 1, f) && fwrite(&b, 1, 1, f) && fwrite(&a, 1, 1, f);
}


//---------------------------------------------------------------------------


//***************************************************************************
void CMoteurRecord::recordFrame(FILE *f, fp64 temps)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 81 EC 000000A0 SUB  ESP, 000000A0
00008: 000C 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00009: 000F 89 CE       MOV     ESI, ECX
{
ui32 diff;
ui32 frameCount;
BStopWatch stop1("CMoteurRecord::recordFrame");
00013: 0011 8D 85 FFFFFF64LEA   EAX, DWORD PTR FFFFFF64[EBP]
00011: 0017 6A 00       PUSH    00000000
00012: 0019 68 00000000 PUSH    OFFSET .data+00000638
00014: 001E 89 C1       MOV     ECX, EAX
00015: 0020 FF 15 00000000 CALL DWORD PTR __imp_??0BStopWatch@@QAE@PBD_N@Z
00016: 0026 83 C4 08    ADD     ESP, 00000008
BStopWatch stop1("CMoteurRecord::recordFrame");
	
	frameCount = mFrameCount;
00018: 0029 8B 86 000000DCMOV   EAX, DWORD PTR 000000DC[ESI]
00019: 002F 89 85 FFFFFF58MOV   DWORD PTR FFFFFF58[EBP], EAX
frameCount = mFrameCount;

	if (mUseSound) recordSoundFrame(f);
00021: 0035 80 BE 000000E000 CMP BYTE PTR 000000E0[ESI], 00000000
00022: 003C 74 0B       JE      L0001
if (mUseSound) recordSoundFrame(f);
00024: 003E 53          PUSH    EBX
00025: 003F 89 F1       MOV     ECX, ESI
00026: 0041 E8 00000000 CALL    NEAR PTR ?recordSoundFrame@CMoteurRecord@@IAEXPAU_FILE@@@Z
00027: 0046                    
00028: 0046 83 C4 04    ADD     ESP, 00000004
00029: 0049     L0001
recordSoundFrame(f);

	grabFrame();
00031: 0049 89 F1       MOV     ECX, ESI
00032: 004B E8 00000000 CALL    NEAR PTR ?grabFrame@CMoteurRecord@@IAEXXZ
00033: 0050                    
grabFrame();
	drawMouse();
00035: 0050 89 F1       MOV     ECX, ESI
00036: 0052 E8 00000000 CALL    NEAR PTR ?drawMouse@CMoteurRecord@@IAEXXZ
00037: 0057                    
drawMouse();
	diff = diffFrame();
00039: 0057 89 F1       MOV     ECX, ESI
00040: 0059 E8 00000000 CALL    NEAR PTR ?diffFrame@CMoteurRecord@@IAEKXZ
00041: 005E                    
00042: 005E             NOOP    
00043: 005E             NOOP    
00044: 005E 89 85 FFFFFF54MOV   DWORD PTR FFFFFF54[EBP], EAX
diff = diffFrame();

	if (diff)
00046: 0064 09 C0       OR      EAX, EAX
00047: 0066 0F 84 000000FA JE   L0002
if (diff)
	{
		// save diff frame -- move to function
		if(1)
		{
			f_bg_write4('DIFF', f);
00049: 006C 53          PUSH    EBX
00051: 006D 89 F1       MOV     ECX, ESI
00050: 006F 68 44494646 PUSH    44494646
00052: 0074 E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00053: 0079                    
00054: 0079 83 C4 08    ADD     ESP, 00000008
f_bg_write4('DIFF', f);
			f_bg_write4(frameCount, f);
00056: 007C 53          PUSH    EBX
00058: 007D 89 F1       MOV     ECX, ESI
00057: 007F FF B5 FFFFFF58PUSH  DWORD PTR FFFFFF58[EBP]
00059: 0085 E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00060: 008A                    
00061: 008A 83 C4 08    ADD     ESP, 00000008
f_bg_write4(frameCount, f);
			f_bg_write4(mDiffLen, f);
00063: 008D 53          PUSH    EBX
00064: 008E 8B 86 000000A0MOV   EAX, DWORD PTR 000000A0[ESI]
00066: 0094 89 F1       MOV     ECX, ESI
00065: 0096 50          PUSH    EAX
00067: 0097 E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00068: 009C                    
00069: 009C 83 C4 08    ADD     ESP, 00000008
f_bg_write4(mDiffLen, f);
			fwrite(mDiffBuffer, 1, mDiffLen, f);
00071: 009F 53          PUSH    EBX
00072: 00A0 8B 86 000000A0MOV   EAX, DWORD PTR 000000A0[ESI]
00073: 00A6 50          PUSH    EAX
00074: 00A7 6A 01       PUSH    00000001
00075: 00A9 8B 86 0000009CMOV   EAX, DWORD PTR 0000009C[ESI]
00076: 00AF 50          PUSH    EAX
00077: 00B0 FF 15 00000000 CALL DWORD PTR __imp__fwrite
00078: 00B6                    
00079: 00B6 83 C4 10    ADD     ESP, 00000010
fwrite(mDiffBuffer, 1, mDiffLen, f);
			fp64 t=systemTime()-temps;
00081: 00B9 FF 15 00000000 CALL DWORD PTR __imp__system_time
00082: 00BF                    
00083: 00BF             NOOP    
00084: 00BF             NOOP    
00085: 00BF 52          PUSH    EDX
00086: 00C0 50          PUSH    EAX
00087: 00C1 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00088: 00C4 50          PUSH    EAX
00089: 00C5 E8 00000000 CALL    NEAR PTR ___rt_s64tof64
00090: 00CA                    
00091: 00CA 83 C4 0C    ADD     ESP, 0000000C
00092: 00CD             NOOP    
00093: 00CD             NOOP    
00094: 00CD DD 00       FLD     QWORD PTR 00000000[EAX]
00095: 00CF DC 65 0C    FSUB    QWORD PTR 0000000C[EBP]
00096: 00D2 DD 55 DC    FST     QWORD PTR FFFFFFDC[EBP]
 t=systemTime()-temps;
			ui32 t1=(ui32)t;
00098: 00D5 D9 BD FFFFFF5CFSTCW WORD PTR FFFFFF5C[EBP]
00099: 00DB 66 81 8D FFFFFF5C0C00 OR WORD PTR FFFFFF5C[EBP], 00000C00
00100: 00E4 D9 AD FFFFFF5CFLDCW WORD PTR FFFFFF5C[EBP]
00101: 00EA DF BD FFFFFF5CFISTP QWORD PTR FFFFFF5C[EBP]
00102: 00F0 8B BD FFFFFF5CMOV   EDI, DWORD PTR FFFFFF5C[EBP]
00103: 00F6 D9 BD FFFFFF5CFSTCW WORD PTR FFFFFF5C[EBP]
00104: 00FC 66 81 A5 FFFFFF5CF3FF AND WORD PTR FFFFFF5C[EBP], 0000F3FF
00105: 0105 D9 AD FFFFFF5CFLDCW WORD PTR FFFFFF5C[EBP]
00106: 010B             NOOP    
 t1=(ui32)t;
			printf("  frame time : %d\n", t1);
00108: 010B 57          PUSH    EDI
00109: 010C 68 00000000 PUSH    OFFSET .data+00000654
00110: 0111 FF 15 00000000 CALL DWORD PTR __imp__printf
00111: 0117                    
00112: 0117 83 C4 08    ADD     ESP, 00000008
printf("  frame time : %d\n", t1);
			f_bg_write4(t1, f);
00114: 011A 53          PUSH    EBX
00115: 011B 57          PUSH    EDI
00116: 011C 89 F1       MOV     ECX, ESI
00117: 011E E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00118: 0123                    
00119: 0123 83 C4 08    ADD     ESP, 00000008
f_bg_write4(t1, f);
			if (debug) fflush(f);
00121: 0126 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00122: 012D 74 0A       JE      L0003
if (debug) fflush(f);
00124: 012F 53          PUSH    EBX
00125: 0130 FF 15 00000000 CALL DWORD PTR __imp__fflush
00126: 0136                    
00127: 0136 83 C4 04    ADD     ESP, 00000004
00128: 0139     L0003
fflush(f);

			_gDiffRec++;
00130: 0139 FF 05 00000000 INC  DWORD PTR __imp__fflush
_gDiffRec++;
		}

		// display if frame is different from previous one
		displayFrame();
00132: 013F 89 F1       MOV     ECX, ESI
00133: 0141 E8 00000000 CALL    NEAR PTR ?displayFrame@CMoteurRecord@@IAEXXZ
00134: 0146                    
displayFrame();

		mFrameDiffTotal += mDiffLen;					// saved data
00136: 0146 8B 86 000000A0MOV   EAX, DWORD PTR 000000A0[ESI]
00137: 014C 01 86 000000D4ADD   DWORD PTR 000000D4[ESI], EAX
mFrameDiffTotal += mDiffLen;					// saved data
		mFrameDiffService += (mDiffLen-diff);	// services codes (rle extra)
00139: 0152 8B 86 000000A0MOV   EAX, DWORD PTR 000000A0[ESI]
00140: 0158 2B 85 FFFFFF54SUB   EAX, DWORD PTR FFFFFF54[EBP]
00141: 015E 01 86 000000D8ADD   DWORD PTR 000000D8[ESI], EAX
mFrameDiffService += (mDiffLen-diff);	// services codes (rle extra)
	}
00143: 0164 EB 35       JMP     L0004
00144: 0166     L0002
}
	else
	{
		// save empty frame (synchro) -- move to function
		if(1)
		{
			f_bg_write4('RALF', f);
00146: 0166 53          PUSH    EBX
00148: 0167 89 F1       MOV     ECX, ESI
00147: 0169 68 52414C46 PUSH    52414C46
00149: 016E E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00150: 0173                    
00151: 0173 83 C4 08    ADD     ESP, 00000008
f_bg_write4('RALF', f);
			f_bg_write4(frameCount, f);
00153: 0176 53          PUSH    EBX
00155: 0177 89 F1       MOV     ECX, ESI
00154: 0179 FF B5 FFFFFF58PUSH  DWORD PTR FFFFFF58[EBP]
00156: 017F E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00157: 0184                    
00158: 0184 83 C4 08    ADD     ESP, 00000008
f_bg_write4(frameCount, f);

			_gConstRec++;
00160: 0187 FF 05 00000000 INC  DWORD PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
_gConstRec++;
		}

		mFrameDiffTotal += 8;					// saved data
00162: 018D 83 86 000000D408 ADD DWORD PTR 000000D4[ESI], 00000008
mFrameDiffTotal += 8;					// saved data
		mFrameDiffService += 8;				// services codes (frame extra)
00164: 0194 83 86 000000D808 ADD DWORD PTR 000000D8[ESI], 00000008
mFrameDiffService += 8;				// services codes (frame extra)
	}
00166: 019B     L0004
}

	if (debug && frameCount%50==0)
00168: 019B 80 3D 00000000 00 CMP BYTE PTR ?_gDebug@@3_NA, 00000000
00169: 01A2 0F 84 0000009B JE   L0005
00170: 01A8 B9 00000032 MOV     ECX, 00000032
00171: 01AD 8B 85 FFFFFF58MOV   EAX, DWORD PTR FFFFFF58[EBP]
00172: 01B3 31 D2       XOR     EDX, EDX
00173: 01B5 F7 F1       DIV     ECX
00174: 01B7 89 D0       MOV     EAX, EDX
00175: 01B9 09 D0       OR      EAX, EDX
00176: 01BB 0F 85 00000082 JNE  L0005
if (debug && frameCount%50==0)
		printf("Frame : total %8d <+%7d> -- RLE %8d <+%7d> -- ratio %7.2lf\n",
00178: 01C1 8B 96 000000D4MOV   EDX, DWORD PTR 000000D4[ESI]
00179: 01C7 09 D2       OR      EDX, EDX
00180: 01C9 74 41       JE      L0006
00181: 01CB 89 D0       MOV     EAX, EDX
00182: 01CD 89 85 FFFFFF5CMOV   DWORD PTR FFFFFF5C[EBP], EAX
00183: 01D3 C7 85 FFFFFF6000000000 MOV DWORD PTR FFFFFF60[EBP], 00000000
00184: 01DD DF AD FFFFFF5CFILD  QWORD PTR FFFFFF5C[EBP]
00185: 01E3 8B 86 000000D8MOV   EAX, DWORD PTR 000000D8[ESI]
00186: 01E9 89 85 FFFFFF5CMOV   DWORD PTR FFFFFF5C[EBP], EAX
00187: 01EF C7 85 FFFFFF6000000000 MOV DWORD PTR FFFFFF60[EBP], 00000000
00188: 01F9 DF AD FFFFFF5CFILD  QWORD PTR FFFFFF5C[EBP]
00189: 01FF DC 0D 00000000 FMUL QWORD PTR .data+00000668
00190: 0205 DE F1       FDIVRP  ST(1), ST
00191: 0207 DD 5D EC    FSTP    QWORD PTR FFFFFFEC[EBP]
00192: 020A EB 0E       JMP     L0007
00193: 020C     L0006
00194: 020C C7 45 EC 00000000 MOV DWORD PTR FFFFFFEC[EBP], 00000000
00195: 0213 C7 45 F0 00000000 MOV DWORD PTR FFFFFFF0[EBP], 00000000
00196: 021A     L0007
00197: 021A FF 75 F0    PUSH    DWORD PTR FFFFFFF0[EBP]
00198: 021D FF 75 EC    PUSH    DWORD PTR FFFFFFEC[EBP]
00199: 0220 FF B5 FFFFFF54PUSH  DWORD PTR FFFFFF54[EBP]
00200: 0226 8B 86 000000D8MOV   EAX, DWORD PTR 000000D8[ESI]
00201: 022C 50          PUSH    EAX
00202: 022D 8B 86 000000A0MOV   EAX, DWORD PTR 000000A0[ESI]
00203: 0233 50          PUSH    EAX
00204: 0234 52          PUSH    EDX
00205: 0235 68 00000000 PUSH    OFFSET .data+00000670
00206: 023A FF 15 00000000 CALL DWORD PTR __imp__printf
00207: 0240                    
00208: 0240 83 C4 1C    ADD     ESP, 0000001C
00209: 0243     L0005
printf("Frame : total %8d <+%7d> -- RLE %8d <+%7d> -- ratio %7.2lf\n",
			mFrameDiffTotal, mDiffLen, mFrameDiffService, diff, (mFrameDiffTotal ? 100.0*mFrameDiffService/mFrameDiffTotal : 0.0));

	// swap frames
	RBitmap *p = mPreviousImg;
00211: 0243 8B 96 00000094MOV   EDX, DWORD PTR 00000094[ESI]
RBitmap *p = mPreviousImg;
	mPreviousImg = mCurrentImg;
00213: 0249 8B 86 00000098MOV   EAX, DWORD PTR 00000098[ESI]
00214: 024F 89 86 00000094MOV   DWORD PTR 00000094[ESI], EAX
mPreviousImg = mCurrentImg;
	mCurrentImg = p;
00216: 0255 89 96 00000098MOV   DWORD PTR 00000098[ESI], EDX
mCurrentImg = p;

	mFrameCount++;
00218: 025B FF 86 000000DCINC   DWORD PTR 000000DC[ESI]
00219: 0261 8D 85 FFFFFF64LEA   EAX, DWORD PTR FFFFFF64[EBP]
00220: 0267 89 C1       MOV     ECX, EAX
00221: 0269 FF 15 00000000 CALL DWORD PTR __imp_??1BStopWatch@@UAE@XZ
mFrameCount++;

} // end of recordFrame for CMoteurRecord
00223: 026F     L0000
00224: 026F 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00225: 0272 5F          POP     EDI
00226: 0273 5E          POP     ESI
00227: 0274 5B          POP     EBX
00228: 0275 5D          POP     EBP
00229: 0276 C3          RETN    

Function: ?grabFrame@CMoteurRecord@@IAEXXZ
} // end of recordFrame for CMoteurRecord


//***************************************************************************
void CMoteurRecord::grabFrame(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 81 EC 000000A4 SUB  ESP, 000000A4
00008: 000C 89 CB       MOV     EBX, ECX
{
BStopWatch stop1("CMoteurRecord::grabFrame");
00012: 000E 8D 85 FFFFFF68LEA   EAX, DWORD PTR FFFFFF68[EBP]
00010: 0014 6A 00       PUSH    00000000
00011: 0016 68 00000000 PUSH    OFFSET .data+000006ac
00013: 001B 89 C1       MOV     ECX, EAX
00014: 001D FF 15 00000000 CALL DWORD PTR __imp_??0BStopWatch@@QAE@PBD_N@Z
00015: 0023 83 C4 08    ADD     ESP, 00000008
BStopWatch stop1("CMoteurRecord::grabFrame");
	BScreen screen(mScreenId);
00018: 0026 8D 45 E0    LEA     EAX, DWORD PTR FFFFFFE0[EBP]
00017: 0029 FF B3 0000012CPUSH  DWORD PTR 0000012C[EBX]
00019: 002F 89 C1       MOV     ECX, EAX
00020: 0031 FF 15 00000000 CALL DWORD PTR __imp_??0BScreen@@QAE@Uscreen_id@@@Z
00021: 0037                    
00022: 0037 83 C4 04    ADD     ESP, 00000004
BScreen screen(mScreenId);

	uint32 sbpr = screen.BytesPerRow();
00024: 003A 8D 45 E0    LEA     EAX, DWORD PTR FFFFFFE0[EBP]
00025: 003D 89 C1       MOV     ECX, EAX
00026: 003F FF 15 00000000 CALL DWORD PTR __imp_?BytesPerRow@BScreen@@QAEKXZ
00027: 0045                    
00028: 0045             NOOP    
00029: 0045             NOOP    
00030: 0045 89 C6       MOV     ESI, EAX
uint32 sbpr = screen.BytesPerRow();
	ui8 *source = (ui8 *)screen.BaseAddress();
00032: 0047 8D 45 E0    LEA     EAX, DWORD PTR FFFFFFE0[EBP]
00033: 004A 89 C1       MOV     ECX, EAX
00034: 004C FF 15 00000000 CALL DWORD PTR __imp_?BaseAddress@BScreen@@QAEPAXXZ
00035: 0052                    
00036: 0052             NOOP    
00037: 0052             NOOP    
00038: 0052 89 85 FFFFFF5CMOV   DWORD PTR FFFFFF5C[EBP], EAX
 *source = (ui8 *)screen.BaseAddress();
	ui8 *dest   = mCurrentImg->data();
00040: 0058 8B 93 00000098MOV   EDX, DWORD PTR 00000098[EBX]
00041: 005E 8B 42 50    MOV     EAX, DWORD PTR 00000050[EDX]
00042: 0061 89 85 FFFFFF58MOV   DWORD PTR FFFFFF58[EBP], EAX
00043: 0067             NOOP    
 *dest   = mCurrentImg->data();
	ui32 dbpr   = mCurrentImg->dataBpr();
00045: 0067 8B 7A 44    MOV     EDI, DWORD PTR 00000044[EDX]
00046: 006A             NOOP    
 dbpr   = mCurrentImg->dataBpr();

	//the case where sbpr == dbpr will be very rare
	//exemple typical screen = 1024x768, recording 640x480 :-(
	//if (sbpr == dbpr)
	//{
	//	memcpy(dest, source, mCurrentImg->dataSxy());
	//}
	//else
	//{
		uint32 ssy	= screen.Frame().Height();
00048: 006A 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00049: 006D 50          PUSH    EAX
00050: 006E 8D 45 E0    LEA     EAX, DWORD PTR FFFFFFE0[EBP]
00051: 0071 89 C1       MOV     ECX, EAX
00052: 0073 FF 15 00000000 CALL DWORD PTR __imp_?Frame@BScreen@@QAE?AVBRect@@XZ
00053: 0079                    
00054: 0079 83 C4 04    ADD     ESP, 00000004
00055: 007C 8D 4D E4    LEA     ECX, DWORD PTR FFFFFFE4[EBP]
00056: 007F             NOOP    
00057: 007F D9 41 0C    FLD     DWORD PTR 0000000C[ECX]
00058: 0082 D8 61 04    FSUB    DWORD PTR 00000004[ECX]
00059: 0085 D9 BD FFFFFF60FSTCW WORD PTR FFFFFF60[EBP]
00060: 008B 66 81 8D FFFFFF600C00 OR WORD PTR FFFFFF60[EBP], 00000C00
00061: 0094 D9 AD FFFFFF60FLDCW WORD PTR FFFFFF60[EBP]
00062: 009A DF BD FFFFFF60FISTP QWORD PTR FFFFFF60[EBP]
00063: 00A0 8B 95 FFFFFF60MOV   EDX, DWORD PTR FFFFFF60[EBP]
00064: 00A6 D9 BD FFFFFF60FSTCW WORD PTR FFFFFF60[EBP]
00065: 00AC 66 81 A5 FFFFFF60F3FF AND WORD PTR FFFFFF60[EBP], 0000F3FF
00069: 00B5 81 FA 000001E0 CMP  EDX, 000001E0
00066: 00BB D9 AD FFFFFF60FLDCW WORD PTR FFFFFF60[EBP]
00067: 00C1             NOOP    
uint32 ssy	= screen.Frame().Height();
		ui32 dsy 		= min(K_SY, ssy);
00070: 00C1 73 07       JAE     L0001
00071: 00C3 B8 000001E0 MOV     EAX, 000001E0
00072: 00C8 EB 02       JMP     L0002
00073: 00CA     L0001
00074: 00CA 89 D0       MOV     EAX, EDX
00075: 00CC     L0002
00076: 00CC 89 85 FFFFFF54MOV   DWORD PTR FFFFFF54[EBP], EAX
 dsy 		= min(K_SY, ssy);
		ui32 bpr		= min(sbpr, dbpr);
00078: 00D2 39 FE       CMP     ESI, EDI
00079: 00D4 76 08       JBE     L0003
00080: 00D6 89 B5 FFFFFF50MOV   DWORD PTR FFFFFF50[EBP], ESI
00081: 00DC EB 35       JMP     L0005
00082: 00DE     L0003
00083: 00DE 89 BD FFFFFF50MOV   DWORD PTR FFFFFF50[EBP], EDI
00084: 00E4     L0004
 bpr		= min(sbpr, dbpr);
		for(; dsy>0; dsy--)
00086: 00E4 EB 2D       JMP     L0005
00087: 00E6     L0006
for(; dsy>0; dsy--)
		{
			memcpy(dest, source, bpr);
00089: 00E6 FF B5 FFFFFF50PUSH  DWORD PTR FFFFFF50[EBP]
00090: 00EC FF B5 FFFFFF5CPUSH  DWORD PTR FFFFFF5C[EBP]
00091: 00F2 FF B5 FFFFFF58PUSH  DWORD PTR FFFFFF58[EBP]
00092: 00F8 FF 15 00000000 CALL DWORD PTR __imp__memcpy
00093: 00FE                    
00094: 00FE 83 C4 0C    ADD     ESP, 0000000C
memcpy(dest, source, bpr);
			source += sbpr;
00096: 0101 01 B5 FFFFFF5CADD   DWORD PTR FFFFFF5C[EBP], ESI
source += sbpr;
			dest += dbpr;
00098: 0107 01 BD FFFFFF58ADD   DWORD PTR FFFFFF58[EBP], EDI
dest += dbpr;
		}
00100: 010D FF 8D FFFFFF54DEC   DWORD PTR FFFFFF54[EBP]
00101: 0113     L0005
00102: 0113 83 BD FFFFFF5400 CMP DWORD PTR FFFFFF54[EBP], 00000000
00103: 011A 75 CA       JNE     L0006
}
	//}

	mDisplay->getScreenMouseLoc(mMouseX, mMouseY);
00105: 011C             NOOP    
00106: 011C 8D 83 000000A8LEA   EAX, DWORD PTR 000000A8[EBX]
00111: 0122 8B 4B 5C    MOV     ECX, DWORD PTR 0000005C[EBX]
00107: 0125 50          PUSH    EAX
00108: 0126             NOOP    
00109: 0126 8D 83 000000A4LEA   EAX, DWORD PTR 000000A4[EBX]
00110: 012C 50          PUSH    EAX
00112: 012D E8 00000000 CALL    NEAR PTR ?getScreenMouseLoc@RBlitWindow@@QAEXAAK0@Z
00113: 0132                    
00114: 0132 83 C4 08    ADD     ESP, 00000008
mDisplay->getScreenMouseLoc(mMouseX, mMouseY);
	mMouseVisible = true;
00116: 0135 C6 83 000000AC01 MOV BYTE PTR 000000AC[EBX], 00000001
mMouseVisible = true;

printf("   ");
00118: 013C 68 00000000 PUSH    OFFSET .data+000006c8
00119: 0141 FF 15 00000000 CALL DWORD PTR __imp__printf
00120: 0147                    
00121: 0147 83 C4 04    ADD     ESP, 00000004
00122: 014A 8D 45 E0    LEA     EAX, DWORD PTR FFFFFFE0[EBP]
00123: 014D 89 C1       MOV     ECX, EAX
00124: 014F FF 15 00000000 CALL DWORD PTR __imp_??1BScreen@@QAE@XZ
00125: 0155                    
00126: 0155 8D 85 FFFFFF68LEA   EAX, DWORD PTR FFFFFF68[EBP]
00127: 015B 89 C1       MOV     ECX, EAX
00128: 015D FF 15 00000000 CALL DWORD PTR __imp_??1BStopWatch@@UAE@XZ
printf("   ");

} // end of grabFrame for CMoteurRecord
00130: 0163     L0000
00131: 0163 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00132: 0166 5F          POP     EDI
00133: 0167 5E          POP     ESI
00134: 0168 5B          POP     EBX
00135: 0169 5D          POP     EBP
00136: 016A C3          RETN    

Function: ?drawMouse@CMoteurRecord@@IAEXXZ
} // end of grabFrame for CMoteurRecord


//***************************************************************************
void CMoteurRecord::drawMouse(void)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 83 EC 10    SUB     ESP, 00000010
00008: 0009 89 CB       MOV     EBX, ECX
{
const ui8 red = 42;
ui8 *dest = mCurrentImg->data();
00010: 000B 8B 8B 00000098MOV   ECX, DWORD PTR 00000098[EBX]
00017: 0011 8B 83 000000A4MOV   EAX, DWORD PTR 000000A4[EBX]
00011: 0017 8B 71 50    MOV     ESI, DWORD PTR 00000050[ECX]
00012: 001A             NOOP    
 *dest = mCurrentImg->data();
ui32 bpr  = mCurrentImg->dataBpr();
00014: 001A 8B 51 44    MOV     EDX, DWORD PTR 00000044[ECX]
00015: 001D             NOOP    
 bpr  = mCurrentImg->dataBpr();
si32 x,y;

	x = mMouseX;
00018: 001D 89 45 E4    MOV     DWORD PTR FFFFFFE4[EBP], EAX
x = mMouseX;
	y = mMouseY;
00020: 0020 8B 8B 000000A8MOV   ECX, DWORD PTR 000000A8[EBX]
y = mMouseY;
	if (mMouseVisible && x < K_SX && y < K_SY)
00022: 0026 80 BB 000000AC00 CMP BYTE PTR 000000AC[EBX], 00000000
00023: 002D 0F 84 000000B7 JE   L0001
00024: 0033 3D 00000280 CMP     EAX, 00000280
00025: 0038 0F 83 000000AC JAE  L0001
00026: 003E 81 F9 000001E0 CMP  ECX, 000001E0
00027: 0044 0F 83 000000A0 JAE  L0001
if (mMouseVisible && x < K_SX && y < K_SY)
	{
		ui8* p = dest+bpr*y+x;
00029: 004A 89 D3       MOV     EBX, EDX
00030: 004C 0F AF D9    IMUL    EBX, ECX
00031: 004F 01 F3       ADD     EBX, ESI
00032: 0051 01 C3       ADD     EBX, EAX
00033: 0053             NOOP    
* p = dest+bpr*y+x;
		ui8* v = p;
00035: 0053 89 DE       MOV     ESI, EBX
* v = p;
		ui8* d = p;
00039: 0055 83 EB 01    SUB     EBX, 00000001
00037: 0058 89 F7       MOV     EDI, ESI
* d = p;
		p -= 1;
p -= 1;
		v -= bpr;
00041: 005A 29 D6       SUB     ESI, EDX
v -= bpr;
		
		si32 c;
		rbool p2, v2;
		p2 = (y+1<K_SY);
00043: 005C             NOOP    
00044: 005C 8D 41 01    LEA     EAX, DWORD PTR 00000001[ECX]
00045: 005F 3D 000001E0 CMP     EAX, 000001E0
00046: 0064 0F 92 45 F0 SETB    BYTE PTR FFFFFFF0[EBP]
00047: 0068             NOOP    
p2 = (y+1<K_SY);
		v2 = (x+1<K_SX);
00049: 0068 8B 45 E4    MOV     EAX, DWORD PTR FFFFFFE4[EBP]
00050: 006B 05 00000001 ADD     EAX, 00000001
00051: 0070 3D 00000280 CMP     EAX, 00000280
00052: 0075 0F 92 45 EC SETB    BYTE PTR FFFFFFEC[EBP]
00053: 0079             NOOP    
v2 = (x+1<K_SX);
		for(c=0; c<10; c++, x++, y++)
00055: 0079 C7 45 E8 00000000 MOV DWORD PTR FFFFFFE8[EBP], 00000000
00056: 0080 EB 62       JMP     L0002
00057: 0082     L0003
for(c=0; c<10; c++, x++, y++)
		{
			if (x>=0 && x<K_SX) { if (p2) p[bpr] = red; *p = red; }		p++;
00059: 0082 83 7D E4 00 CMP     DWORD PTR FFFFFFE4[EBP], 00000000
00060: 0086 7C 16       JL      L0004
00061: 0088 81 7D E4 00000280 CMP DWORD PTR FFFFFFE4[EBP], 00000280
00062: 008F 73 0D       JAE     L0004
if (x>=0 && x<K_SX) { if (p2) p[bpr] = red; *p = red; }		p++;
00064: 0091 80 7D F0 00 CMP     BYTE PTR FFFFFFF0[EBP], 00000000
00065: 0095 74 04       JE      L0005
if (p2) p[bpr] = red; *p = red; }		p++;
00067: 0097 C6 04 13 2A MOV     BYTE PTR 00000000[EBX][EDX], 0000002A
00068: 009B     L0005
p[bpr] = red; *p = red; }		p++;
00070: 009B C6 03 2A    MOV     BYTE PTR 00000000[EBX], 0000002A
*p = red; }		p++;
00072: 009E     L0004
}		p++;
00074: 009E 43          INC     EBX
p++;
			if (y>=0 && y<K_SX) { if (v2) v[1] = red; *v = red; }			v+=bpr; 
00076: 009F 09 C9       OR      ECX, ECX
00077: 00A1 7C 15       JL      L0006
00078: 00A3 81 F9 00000280 CMP  ECX, 00000280
00079: 00A9 73 0D       JAE     L0006
if (y>=0 && y<K_SX) { if (v2) v[1] = red; *v = red; }			v+=bpr; 
00081: 00AB 80 7D EC 00 CMP     BYTE PTR FFFFFFEC[EBP], 00000000
00082: 00AF 74 04       JE      L0007
if (v2) v[1] = red; *v = red; }			v+=bpr; 
00084: 00B1 C6 46 01 2A MOV     BYTE PTR 00000001[ESI], 0000002A
00085: 00B5     L0007
v[1] = red; *v = red; }			v+=bpr; 
00087: 00B5 C6 06 2A    MOV     BYTE PTR 00000000[ESI], 0000002A
*v = red; }			v+=bpr; 
00089: 00B8     L0006
}			v+=bpr; 
00091: 00B8 01 D6       ADD     ESI, EDX
v+=bpr; 
			if (x>=0 && x<K_SX && y>=0 && y<K_SX) *d = red;						d+=bpr+1;
00093: 00BA 83 7D E4 00 CMP     DWORD PTR FFFFFFE4[EBP], 00000000
00094: 00BE 7C 18       JL      L0008
00095: 00C0 81 7D E4 00000280 CMP DWORD PTR FFFFFFE4[EBP], 00000280
00096: 00C7 73 0F       JAE     L0008
00097: 00C9 09 C9       OR      ECX, ECX
00098: 00CB 7C 0B       JL      L0008
00099: 00CD 81 F9 00000280 CMP  ECX, 00000280
00100: 00D3 73 03       JAE     L0008
if (x>=0 && x<K_SX && y>=0 && y<K_SX) *d = red;						d+=bpr+1;
00102: 00D5 C6 07 2A    MOV     BYTE PTR 00000000[EDI], 0000002A
00103: 00D8     L0008
*d = red;						d+=bpr+1;
00105: 00D8             NOOP    
00106: 00D8 8D 42 01    LEA     EAX, DWORD PTR 00000001[EDX]
00107: 00DB 01 C7       ADD     EDI, EAX
d+=bpr+1;
		}
00109: 00DD FF 45 E8    INC     DWORD PTR FFFFFFE8[EBP]
00110: 00E0 FF 45 E4    INC     DWORD PTR FFFFFFE4[EBP]
00111: 00E3 41          INC     ECX
00112: 00E4     L0002
00113: 00E4 83 7D E8 0A CMP     DWORD PTR FFFFFFE8[EBP], 0000000A
00114: 00E8 7C 98       JL      L0003
}
	}
00116: 00EA     L0001
}

} // end of drawMouse for CMoteurRecord
00118: 00EA     L0000
00119: 00EA 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00120: 00ED 5F          POP     EDI
00121: 00EE 5E          POP     ESI
00122: 00EF 5B          POP     EBX
00123: 00F0 5D          POP     EBP
00124: 00F1 C3          RETN    

Function: ?diffFrame@CMoteurRecord@@IAEKXZ
} // end of drawMouse for CMoteurRecord


//***************************************************************************
ui32 CMoteurRecord::diffFrame(void)
//***************************************************************************
// simple RLE encoding
// return true if images are different
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 81 EC 00000090 SUB  ESP, 00000090
00008: 000C 89 CB       MOV     EBX, ECX
{
BStopWatch stop1("CMoteurRecord::diffFrame");
00012: 000E 8D 85 FFFFFF7CLEA   EAX, DWORD PTR FFFFFF7C[EBP]
00010: 0014 6A 00       PUSH    00000000
00011: 0016 68 00000000 PUSH    OFFSET .data+000006cc
00013: 001B 89 C1       MOV     ECX, EAX
00014: 001D FF 15 00000000 CALL DWORD PTR __imp_??0BStopWatch@@QAE@PBD_N@Z
00015: 0023 83 C4 08    ADD     ESP, 00000008
BStopWatch stop1("CMoteurRecord::diffFrame");
ui8 *pold = mPreviousImg->data();
00017: 0026 8B 93 00000094MOV   EDX, DWORD PTR 00000094[EBX]
00029: 002C 31 FF       XOR     EDI, EDI
00018: 002E 8B 42 50    MOV     EAX, DWORD PTR 00000050[EDX]
00019: 0031 89 85 FFFFFF68MOV   DWORD PTR FFFFFF68[EBP], EAX
00020: 0037             NOOP    
 *pold = mPreviousImg->data();
ui8 *pnew = mCurrentImg->data();
00022: 0037 8B 93 00000098MOV   EDX, DWORD PTR 00000098[EBX]
00026: 003D 8B 83 0000009CMOV   EAX, DWORD PTR 0000009C[EBX]
00023: 0043 8B 4A 50    MOV     ECX, DWORD PTR 00000050[EDX]
00024: 0046             NOOP    
 *pnew = mCurrentImg->data();
ui8 *diff = mDiffBuffer;
00027: 0046 89 85 FFFFFF6CMOV   DWORD PTR FFFFFF6C[EBP], EAX
 *diff = mDiffBuffer;
ui8 *diffcount;
ui32 diffBytes = 0;
 diffBytes = 0;
ui32 sxy = mCurrentImg->dataSxy();
00031: 004C 8B 42 38    MOV     EAX, DWORD PTR 00000038[EDX]
00032: 004F 89 85 FFFFFF70MOV   DWORD PTR FFFFFF70[EBP], EAX
00033: 0055             NOOP    
 sxy = mCurrentImg->dataSxy();
ui32 count;
rbool forcediff;

	//if (debug) printf("CMoteurRecord::diffFrame -- pold %p pnew %p diff %p\n", pold, pnew, diff);
	while(sxy)
00035: 0055 E9 00000178 JMP     L0001
00036: 005A     L0002
while(sxy)
	{
		//if (debug) printf("%6d", sxy);
		// find identical-rung
		forcediff = false;
00038: 005A C6 85 FFFFFF7400 MOV BYTE PTR FFFFFF74[EBP], 00000000
forcediff = false;
		for(count=0; count<16384-2+3 && sxy && *pold == *pnew; count++, pold++, pnew++, sxy--) /* nop */;
00040: 0061 C7 85 FFFFFF6400000000 MOV DWORD PTR FFFFFF64[EBP], 00000000
00041: 006B EB 13       JMP     L0003
00042: 006D     L0004
for(count=0; count<16384-2+3 && sxy && *pold == *pnew; count++, pold++, pnew++, sxy--) /* nop */;
00044: 006D FF 85 FFFFFF64INC   DWORD PTR FFFFFF64[EBP]
00045: 0073 FF 85 FFFFFF68INC   DWORD PTR FFFFFF68[EBP]
00046: 0079 41          INC     ECX
00047: 007A FF 8D FFFFFF70DEC   DWORD PTR FFFFFF70[EBP]
00048: 0080     L0003
00049: 0080 81 BD FFFFFF6400004001 CMP DWORD PTR FFFFFF64[EBP], 00004001
00050: 008A 73 17       JAE     L0005
00051: 008C 83 BD FFFFFF7000 CMP DWORD PTR FFFFFF70[EBP], 00000000
00052: 0093 74 0E       JE      L0005
00053: 0095 8B 85 FFFFFF68MOV   EAX, DWORD PTR FFFFFF68[EBP]
00054: 009B 8A 10       MOV     DL, BYTE PTR 00000000[EAX]
00055: 009D 8A 01       MOV     AL, BYTE PTR 00000000[ECX]
00056: 009F 38 C2       CMP     DL, AL
00057: 00A1 74 CA       JE      L0004
00058: 00A3     L0005
;
		if (count>64-1+3)
00060: 00A3 83 BD FFFFFF6442 CMP DWORD PTR FFFFFF64[EBP], 00000042
00061: 00AA 76 3A       JBE     L0006
if (count>64-1+3)
		{
			// write identical count if at least 3 and max 16384-1+3
			ui8 a,b;
			count -= 3;
00063: 00AC 83 AD FFFFFF6403 SUB DWORD PTR FFFFFF64[EBP], 00000003
count -= 3;
			a = count & 0x3F;
			b = count>>6;
			*(diff++) = 128+64+a;
00065: 00B3 8A 95 FFFFFF64MOV   DL, BYTE PTR FFFFFF64[EBP]
00068: 00B9 8B 85 FFFFFF6CMOV   EAX, DWORD PTR FFFFFF6C[EBP]
00066: 00BF 80 E2 3F    AND     DL, 0000003F
00067: 00C2 80 C2 C0    ADD     DL, 000000C0
00069: 00C5 FF 85 FFFFFF6CINC   DWORD PTR FFFFFF6C[EBP]
00070: 00CB 88 10       MOV     BYTE PTR 00000000[EAX], DL
*(diff++) = 128+64+a;
			*(diff++) = b;
00072: 00CD 8B 95 FFFFFF64MOV   EDX, DWORD PTR FFFFFF64[EBP]
00074: 00D3 8B 85 FFFFFF6CMOV   EAX, DWORD PTR FFFFFF6C[EBP]
00073: 00D9 C1 EA 06    SHR     EDX, 00000006
00075: 00DC FF 85 FFFFFF6CINC   DWORD PTR FFFFFF6C[EBP]
00076: 00E2 88 10       MOV     BYTE PTR 00000000[EAX], DL
*(diff++) = b;
		}
00078: 00E4 EB 5C       JMP     L0007
00079: 00E6     L0006
}
		else if (count>2)
00081: 00E6 83 BD FFFFFF6402 CMP DWORD PTR FFFFFF64[EBP], 00000002
00082: 00ED 76 19       JBE     L0008
if (count>2)
		{
			// write identical count if at least 3 and max 64-1+3
			*(diff++) = 128+count-3;
00084: 00EF 8A 95 FFFFFF64MOV   DL, BYTE PTR FFFFFF64[EBP]
00086: 00F5 8B 85 FFFFFF6CMOV   EAX, DWORD PTR FFFFFF6C[EBP]
00085: 00FB 80 C2 7D    ADD     DL, 0000007D
00087: 00FE FF 85 FFFFFF6CINC   DWORD PTR FFFFFF6C[EBP]
00088: 0104 88 10       MOV     BYTE PTR 00000000[EAX], DL
*(diff++) = 128+count-3;
		}
00090: 0106 EB 3A       JMP     L0009
00091: 0108     L0008
}
		else if (count)
00093: 0108 83 BD FFFFFF6400 CMP DWORD PTR FFFFFF64[EBP], 00000000
00094: 010F 74 31       JE      L000A
if (count)
		{
			// force a diff-rung
			forcediff = true;
00096: 0111 C6 85 FFFFFF7401 MOV BYTE PTR FFFFFF74[EBP], 00000001
forcediff = true;
			pold -= count;
00098: 0118 8B 85 FFFFFF68MOV   EAX, DWORD PTR FFFFFF68[EBP]
00099: 011E 2B 85 FFFFFF64SUB   EAX, DWORD PTR FFFFFF64[EBP]
00100: 0124 89 85 FFFFFF68MOV   DWORD PTR FFFFFF68[EBP], EAX
pold -= count;
			pnew -= count;
00102: 012A 2B 8D FFFFFF64SUB   ECX, DWORD PTR FFFFFF64[EBP]
pnew -= count;
			sxy += count;
00104: 0130 8B 85 FFFFFF70MOV   EAX, DWORD PTR FFFFFF70[EBP]
00105: 0136 03 85 FFFFFF64ADD   EAX, DWORD PTR FFFFFF64[EBP]
00106: 013C 89 85 FFFFFF70MOV   DWORD PTR FFFFFF70[EBP], EAX
sxy += count;
		}
00108: 0142     L000A
00109: 0142     L0009
00110: 0142     L0007
}
		
		// find difference-rung
		diffcount = diff++;
00112: 0142 8B B5 FFFFFF6CMOV   ESI, DWORD PTR FFFFFF6C[EBP]
00113: 0148 FF 85 FFFFFF6CINC   DWORD PTR FFFFFF6C[EBP]
00114: 014E             NOOP    
diffcount = diff++;
		for(count=0; count<127 && sxy && ((forcediff && count<3) || *pold != *pnew); count++, pold++, sxy--) *(diff++)=*(pnew++);
00116: 014E C7 85 FFFFFF6400000000 MOV DWORD PTR FFFFFF64[EBP], 00000000
00117: 0158 EB 25       JMP     L000B
00118: 015A     L000C
for(count=0; count<127 && sxy && ((forcediff && count<3) || *pold != *pnew); count++, pold++, sxy--) *(diff++)=*(pnew++);
00120: 015A 89 C8       MOV     EAX, ECX
00121: 015C 41          INC     ECX
00122: 015D 8B 95 FFFFFF6CMOV   EDX, DWORD PTR FFFFFF6C[EBP]
00123: 0163 FF 85 FFFFFF6CINC   DWORD PTR FFFFFF6C[EBP]
00124: 0169 8A 00       MOV     AL, BYTE PTR 00000000[EAX]
00125: 016B 88 02       MOV     BYTE PTR 00000000[EDX], AL
00126: 016D FF 85 FFFFFF64INC   DWORD PTR FFFFFF64[EBP]
00127: 0173 FF 85 FFFFFF68INC   DWORD PTR FFFFFF68[EBP]
00128: 0179 FF 8D FFFFFF70DEC   DWORD PTR FFFFFF70[EBP]
00129: 017F     L000B
00130: 017F 83 BD FFFFFF647F CMP DWORD PTR FFFFFF64[EBP], 0000007F
00131: 0186 73 29       JAE     L000D
00132: 0188 83 BD FFFFFF7000 CMP DWORD PTR FFFFFF70[EBP], 00000000
00133: 018F 74 20       JE      L000D
00134: 0191 80 BD FFFFFF7400 CMP BYTE PTR FFFFFF74[EBP], 00000000
00135: 0198 74 09       JE      L000E
00136: 019A 83 BD FFFFFF6403 CMP DWORD PTR FFFFFF64[EBP], 00000003
00137: 01A1 72 B7       JB      L000C
00138: 01A3     L000E
00139: 01A3 8B 85 FFFFFF68MOV   EAX, DWORD PTR FFFFFF68[EBP]
00140: 01A9 8A 10       MOV     DL, BYTE PTR 00000000[EAX]
00141: 01AB 8A 01       MOV     AL, BYTE PTR 00000000[ECX]
00142: 01AD 38 C2       CMP     DL, AL
00143: 01AF 75 A9       JNE     L000C
00144: 01B1     L000D
*(diff++)=*(pnew++);
		if (count > 0)
00146: 01B1 83 BD FFFFFF6400 CMP DWORD PTR FFFFFF64[EBP], 00000000
00147: 01B8 74 12       JE      L000F
if (count > 0)
		{
			// write a diff rung (count is from 1->128, saved 0->127)
			diffBytes += count;
00149: 01BA 03 BD FFFFFF64ADD   EDI, DWORD PTR FFFFFF64[EBP]
diffBytes += count;
			*diffcount = count-1;
00151: 01C0 8A 85 FFFFFF64MOV   AL, BYTE PTR FFFFFF64[EBP]
00152: 01C6 04 FF       ADD     AL, 000000FF
00153: 01C8 88 06       MOV     BYTE PTR 00000000[ESI], AL
*diffcount = count-1;
		}
00155: 01CA EB 06       JMP     L0010
00156: 01CC     L000F
}
		else diff = diffcount;
00158: 01CC 89 B5 FFFFFF6CMOV   DWORD PTR FFFFFF6C[EBP], ESI
00159: 01D2     L0010
diff = diffcount;
	}
00161: 01D2     L0001
00162: 01D2 83 BD FFFFFF7000 CMP DWORD PTR FFFFFF70[EBP], 00000000
00163: 01D9 0F 85 FFFFFE7B JNE  L0002
}

	mDiffLen = diff-mDiffBuffer;
00165: 01DF 8B 85 FFFFFF6CMOV   EAX, DWORD PTR FFFFFF6C[EBP]
00166: 01E5 2B 83 0000009CSUB   EAX, DWORD PTR 0000009C[EBX]
00167: 01EB 89 83 000000A0MOV   DWORD PTR 000000A0[EBX], EAX
mDiffLen = diff-mDiffBuffer;
	//if (debug) printf("\ndiff len %d\n", mDiffLen);
printf("   ");
00169: 01F1 68 00000000 PUSH    OFFSET .data+000006e8
00170: 01F6 FF 15 00000000 CALL DWORD PTR __imp__printf
00171: 01FC                    
00172: 01FC 83 C4 04    ADD     ESP, 00000004
printf("   ");
	return diffBytes;
00174: 01FF 8D 85 FFFFFF7CLEA   EAX, DWORD PTR FFFFFF7C[EBP]
00175: 0205 89 C1       MOV     ECX, EAX
00176: 0207 FF 15 00000000 CALL DWORD PTR __imp_??1BStopWatch@@UAE@XZ
00177: 020D 89 F8       MOV     EAX, EDI
00178: 020F     L0000
00179: 020F 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00180: 0212 5F          POP     EDI
00181: 0213 5E          POP     ESI
00182: 0214 5B          POP     EBX
00183: 0215 5D          POP     EBP
00184: 0216 C3          RETN    

Function: ?recordSoundFrame@CMoteurRecord@@IAEXPAU_FILE@@@Z
return diffBytes;

} // end of diffFrame for CMoteurRecord


//---------------------------------------------------------------------------


//***************************************************************************
void CMoteurRecord::recordSoundFrame(FILE *f)
//***************************************************************************
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 81 EC 000000A8 SUB  ESP, 000000A8
00008: 000C 89 CB       MOV     EBX, ECX
{
ui32 nbBuf;
ui32 frameCount;

BStopWatch stop1("CMoteurRecord::recordSoundFrame");
00012: 000E 8D 85 FFFFFF64LEA   EAX, DWORD PTR FFFFFF64[EBP]
00010: 0014 6A 00       PUSH    00000000
00011: 0016 68 00000000 PUSH    OFFSET .data+000006ec
00013: 001B 89 C1       MOV     ECX, EAX
00014: 001D FF 15 00000000 CALL DWORD PTR __imp_??0BStopWatch@@QAE@PBD_N@Z
00015: 0023 83 C4 08    ADD     ESP, 00000008
BStopWatch stop1("CMoteurRecord::recordSoundFrame");

	frameCount = mFrameCount;
00017: 0026 8B B3 000000DCMOV   ESI, DWORD PTR 000000DC[EBX]
frameCount = mFrameCount;

	// important : while this function executes (at the end of recording the
	// current frame), the audio stream is still actively adding more buffers
	// to the audio list.
	//
	// thus the idea is to read the current number of buffer right now
	// and then only store these buffers. the remaining buffer will be saved
	// at next frame.
	//
	// the size method just returns an int, so it can be safely called without
	// locking the buffer list. we know the count may become obsolete right after
	// that operation.

	nbBuf = mSharedSoundBuffer.mList.size();
00019: 002C 8B 83 000000F0MOV   EAX, DWORD PTR 000000F0[EBX]
00020: 0032 89 85 FFFFFF5CMOV   DWORD PTR FFFFFF5C[EBP], EAX
00021: 0038             NOOP    
nbBuf = mSharedSoundBuffer.mList.size();
	//if(debug) printf("recordSoundFrame -- nb buf == %d\n", nbBuf);

	// nothing to save ? give up.
	if (!nbBuf) return;
00023: 0038 83 BD FFFFFF5C00 CMP DWORD PTR FFFFFF5C[EBP], 00000000
00024: 003F 75 16       JNE     L0001
00025: 0041 8D 85 FFFFFF64LEA   EAX, DWORD PTR FFFFFF64[EBP]
00026: 0047 89 C1       MOV     ECX, EAX
00027: 0049 FF 15 00000000 CALL DWORD PTR __imp_??1BStopWatch@@UAE@XZ
if (!nbBuf) return;
00029: 004F 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00030: 0052 5F          POP     EDI
00031: 0053 5E          POP     ESI
00032: 0054 5B          POP     EBX
00033: 0055 5D          POP     EBP
00034: 0056 C3          RETN    
00035: 0057     L0001
return;

	// write header
	f_bg_write4('APCM', f);
00037: 0057 FF 75 08    PUSH    DWORD PTR 00000008[EBP]
00038: 005A 68 4150434D PUSH    4150434D
00039: 005F 89 D9       MOV     ECX, EBX
00040: 0061 E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00041: 0066                    
00042: 0066 83 C4 08    ADD     ESP, 00000008
f_bg_write4('APCM', f);
	f_bg_write4(frameCount, f);
00046: 0069 89 D9       MOV     ECX, EBX
00044: 006B FF 75 08    PUSH    DWORD PTR 00000008[EBP]
00045: 006E 56          PUSH    ESI
00047: 006F E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00048: 0074                    
00049: 0074 83 C4 08    ADD     ESP, 00000008
00050: 0077 B8 00000008 MOV     EAX, OFFSET ??_7RErrEx@@6B@+00000008
00051: 007C 89 85 FFFFFF50MOV   DWORD PTR FFFFFF50[EBP], EAX
f_bg_write4(frameCount, f);

	// process buffers
	for(; nbBuf > 0; nbBuf--)
00053: 0082 E9 000001B5 JMP     L0002
00054: 0087     L0003
for(; nbBuf > 0; nbBuf--)
	{
		SSoundBuffer *buf;

		mSharedSoundBuffer.mSem.acquire();
00056: 0087 83 BB 00000104FF CMP DWORD PTR 00000104[EBX], FFFFFFFF
00057: 008E 74 10       JE      L0004
00058: 0090 8B 83 00000104MOV   EAX, DWORD PTR 00000104[EBX]
00059: 0096 50          PUSH    EAX
00060: 0097 FF 15 00000000 CALL DWORD PTR __imp__acquire_sem
00061: 009D                    
00062: 009D 83 C4 04    ADD     ESP, 00000004
00063: 00A0     L0004
mSharedSoundBuffer.mSem.acquire();
		buf = mSharedSoundBuffer.mList.removeFirst();
00065: 00A0 8B 93 000000F4MOV   EDX, DWORD PTR 000000F4[EBX]
00066: 00A6 09 D2       OR      EDX, EDX
00067: 00A8 75 04       JNE     L0005
00068: 00AA 31 F6       XOR     ESI, ESI
00069: 00AC EB 29       JMP     L0006
00070: 00AE     L0005
00071: 00AE 8B 83 000000F4MOV   EAX, DWORD PTR 000000F4[EBX]
00072: 00B4 8B 00       MOV     EAX, DWORD PTR 00000000[EAX]
00073: 00B6 89 83 000000F4MOV   DWORD PTR 000000F4[EBX], EAX
00074: 00BC 83 BB 000000F400 CMP DWORD PTR 000000F4[EBX], 00000000
00075: 00C3 75 0A       JNE     L0007
00076: 00C5 C7 83 000000F800000000 MOV DWORD PTR 000000F8[EBX], 00000000
00077: 00CF     L0007
00078: 00CF FF 8B 000000F0DEC   DWORD PTR 000000F0[EBX]
00079: 00D5 89 D6       MOV     ESI, EDX
00080: 00D7     L0006
buf = mSharedSoundBuffer.mList.removeFirst();
		mSharedSoundBuffer.mSem.release();
00082: 00D7 83 BB 00000104FF CMP DWORD PTR 00000104[EBX], FFFFFFFF
00083: 00DE 74 10       JE      L0008
00084: 00E0 8B 83 00000104MOV   EAX, DWORD PTR 00000104[EBX]
00085: 00E6 50          PUSH    EAX
00086: 00E7 FF 15 00000000 CALL DWORD PTR __imp__release_sem
00087: 00ED                    
00088: 00ED 83 C4 04    ADD     ESP, 00000004
00089: 00F0     L0008
mSharedSoundBuffer.mSem.release();

		if (!buf)
00091: 00F0 09 F6       OR      ESI, ESI
00092: 00F2 75 25       JNE     L0009
if (!buf)
		{
			// there are less buffers than expected, write a null-size
			// tag in the file and give up.
			f_bg_write4(0, f);
00096: 00F4 89 D9       MOV     ECX, EBX
00094: 00F6 FF 75 08    PUSH    DWORD PTR 00000008[EBP]
00095: 00F9 6A 00       PUSH    00000000
00097: 00FB E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00098: 0100                    
00099: 0100 83 C4 08    ADD     ESP, 00000008
00100: 0103 8D 85 FFFFFF64LEA   EAX, DWORD PTR FFFFFF64[EBP]
00101: 0109 89 C1       MOV     ECX, EAX
00102: 010B FF 15 00000000 CALL DWORD PTR __imp_??1BStopWatch@@UAE@XZ
f_bg_write4(0, f);
			return;
00104: 0111 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00105: 0114 5F          POP     EDI
00106: 0115 5E          POP     ESI
00107: 0116 5B          POP     EBX
00108: 0117 5D          POP     EBP
00109: 0118 C3          RETN    
return;
		}
00111: 0119     L0009
}

		// write number of _samples_ (not bytes !!)
		// when we will store the ADPCM data, we know the compression has
		// a factor of 1/4 in bytes-size, so there will be samples/2 bytes
		// in the compressed buffer
		
		ui32 nbSample = buf->mNbSample;
00113: 0119 8B 7E 08    MOV     EDI, DWORD PTR 00000008[ESI]
 nbSample = buf->mNbSample;
		ui32 nbSample2 = nbSample/2;
00121: 011C 89 D9       MOV     ECX, EBX
00115: 011E 89 BD FFFFFF4CMOV   DWORD PTR FFFFFF4C[EBP], EDI
00116: 0124 D1 AD FFFFFF4CSHR   DWORD PTR FFFFFF4C[EBP], 00000001
00117: 012A             NOOP    
 nbSample2 = nbSample/2;
		f_bg_write4(nbSample, f);
00119: 012A FF 75 08    PUSH    DWORD PTR 00000008[EBP]
00120: 012D 57          PUSH    EDI
00122: 012E E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00123: 0133                    
00124: 0133 83 C4 08    ADD     ESP, 00000008
f_bg_write4(nbSample, f);
		
		// use memory pool or create a new memory buffer for compressing ?
		// (the memory pool is ideally the same size than one recorded buffer from
		// the Media kit, thus the compressed data _should_ fit always !!)
		rbool usePool = (nbSample2 <= mMemoryPoolSize);
00126: 0136 8B 85 FFFFFF4CMOV   EAX, DWORD PTR FFFFFF4C[EBP]
00127: 013C 3B 83 000000E8CMP   EAX, DWORD PTR 000000E8[EBX]
00128: 0142 0F 96 85 FFFFFF60SETBE BYTE PTR FFFFFF60[EBP]
00129: 0149             NOOP    
 usePool = (nbSample2 <= mMemoryPoolSize);

		// allocate the memory for the compressed data
		ui8 *abuf;
		if (usePool) abuf = (ui8 *)mMemoryPool;
00131: 0149 80 BD FFFFFF6000 CMP BYTE PTR FFFFFF60[EBP], 00000000
00132: 0150 74 0E       JE      L000A
if (usePool) abuf = (ui8 *)mMemoryPool;
00134: 0152 8B 83 000000E4MOV   EAX, DWORD PTR 000000E4[EBX]
00135: 0158 89 85 FFFFFF58MOV   DWORD PTR FFFFFF58[EBP], EAX
00136: 015E EB 6D       JMP     L000B
00137: 0160     L000A
abuf = (ui8 *)mMemoryPool;
		else
		{
			abuf = new ui8[nbSample2];
00139: 0160 8B 85 FFFFFF4CMOV   EAX, DWORD PTR FFFFFF4C[EBP]
00140: 0166 C1 E0 00    SHL     EAX, 00000000
00141: 0169 50          PUSH    EAX
00142: 016A E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00143: 016F                    
00144: 016F 83 C4 04    ADD     ESP, 00000004
00145: 0172             NOOP    
00146: 0172             NOOP    
00147: 0172 89 85 FFFFFF58MOV   DWORD PTR FFFFFF58[EBP], EAX
abuf = new ui8[nbSample2];
			M_ASSERT_PTR(abuf); // HOOK TBDL : report failure to CMoteurRecord ?
00149: 0178 09 C0       OR      EAX, EAX
00150: 017A 75 51       JNE     L000C
00154: 017C 8D 45 E8    LEA     EAX, DWORD PTR FFFFFFE8[EBP]
00151: 017F 68 000002D5 PUSH    000002D5
00152: 0184 68 00000000 PUSH    OFFSET .data+0000070c
00153: 0189 68 00000000 PUSH    OFFSET .data+00000720
00155: 018E 89 C1       MOV     ECX, EAX
00156: 0190 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00157: 0195                    
00158: 0195 83 C4 0C    ADD     ESP, 0000000C
00159: 0198 8B 85 FFFFFF50MOV   EAX, DWORD PTR FFFFFF50[EBP]
00160: 019E 89 45 DC    MOV     DWORD PTR FFFFFFDC[EBP], EAX
00161: 01A1 8B 45 EC    MOV     EAX, DWORD PTR FFFFFFEC[EBP]
00162: 01A4 89 45 E0    MOV     DWORD PTR FFFFFFE0[EBP], EAX
00163: 01A7 8B 45 F0    MOV     EAX, DWORD PTR FFFFFFF0[EBP]
00164: 01AA 89 45 E4    MOV     DWORD PTR FFFFFFE4[EBP], EAX
00165: 01AD BA 00000000 MOV     EDX, OFFSET .data+00000728
00167: 01B2 8D 45 DC    LEA     EAX, DWORD PTR FFFFFFDC[EBP]
00166: 01B5 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00168: 01BA 50          PUSH    EAX
00169: 01BB 52          PUSH    EDX
00170: 01BC E8 00000000 CALL    NEAR PTR ___throw
00171: 01C1                    
00172: 01C1 83 C4 0C    ADD     ESP, 0000000C
00173: 01C4 8B 85 FFFFFF50MOV   EAX, DWORD PTR FFFFFF50[EBP]
00174: 01CA 89 45 E8    MOV     DWORD PTR FFFFFFE8[EBP], EAX
00175: 01CD     L000C
; // HOOK TBDL : report failure to CMoteurRecord ?
		}
00177: 01CD     L000B
}

		//  and compress it
		mAdpcmCodec.encode(buf->mBuffer, abuf, nbSample);
00179: 01CD 57          PUSH    EDI
00181: 01CE 8B 46 04    MOV     EAX, DWORD PTR 00000004[ESI]
00180: 01D1 FF B5 FFFFFF58PUSH  DWORD PTR FFFFFF58[EBP]
00182: 01D7 50          PUSH    EAX
00183: 01D8             NOOP    
00184: 01D8 8D 83 00000124LEA   EAX, DWORD PTR 00000124[EBX]
00185: 01DE 89 C1       MOV     ECX, EAX
00186: 01E0 8B 39       MOV     EDI, DWORD PTR 00000000[ECX]
00187: 01E2 FF 57 04    CALL    DWORD PTR 00000004[EDI]
00188: 01E5                    
00189: 01E5 83 C4 0C    ADD     ESP, 0000000C
mAdpcmCodec.encode(buf->mBuffer, abuf, nbSample);

		// save data
		fwrite(abuf, 1, nbSample2, f);
00191: 01E8 FF 75 08    PUSH    DWORD PTR 00000008[EBP]
00192: 01EB FF B5 FFFFFF4CPUSH  DWORD PTR FFFFFF4C[EBP]
00193: 01F1 6A 01       PUSH    00000001
00194: 01F3 FF B5 FFFFFF58PUSH  DWORD PTR FFFFFF58[EBP]
00195: 01F9 FF 15 00000000 CALL DWORD PTR __imp__fwrite
00196: 01FF                    
00197: 01FF 83 C4 10    ADD     ESP, 00000010
fwrite(abuf, 1, nbSample2, f);

		// free data and buffer
		delete buf;
00199: 0202 09 F6       OR      ESI, ESI
00200: 0204 74 19       JE      L000D
00201: 0206 8B 46 04    MOV     EAX, DWORD PTR 00000004[ESI]
00202: 0209 09 C0       OR      EAX, EAX
00203: 020B 74 09       JE      L000E
00204: 020D 50          PUSH    EAX
00205: 020E E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00206: 0213                    
00207: 0213 83 C4 04    ADD     ESP, 00000004
00208: 0216     L000E
00209: 0216 56          PUSH    ESI
00210: 0217 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00211: 021C                    
00212: 021C 83 C4 04    ADD     ESP, 00000004
00213: 021F     L000D
delete buf;
		if (!usePool) delete abuf;
00215: 021F 80 BD FFFFFF6000 CMP BYTE PTR FFFFFF60[EBP], 00000000
00216: 0226 75 0E       JNE     L000F
if (!usePool) delete abuf;
00218: 0228 FF B5 FFFFFF58PUSH  DWORD PTR FFFFFF58[EBP]
00219: 022E E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00220: 0233                    
00221: 0233 83 C4 04    ADD     ESP, 00000004
00222: 0236     L000F
delete abuf;
	}
00224: 0236 FF 8D FFFFFF5CDEC   DWORD PTR FFFFFF5C[EBP]
00225: 023C     L0002
00226: 023C 83 BD FFFFFF5C00 CMP DWORD PTR FFFFFF5C[EBP], 00000000
00227: 0243 0F 85 FFFFFE3E JNE  L0003
}

	// indicate that the list of buffer is finished by writing a null-size tag
	f_bg_write4(0, f);
00231: 0249 89 D9       MOV     ECX, EBX
00229: 024B FF 75 08    PUSH    DWORD PTR 00000008[EBP]
00230: 024E 6A 00       PUSH    00000000
00232: 0250 E8 00000000 CALL    NEAR PTR ?f_bg_write4@CMoteurRecord@@IAEEKPAU_FILE@@@Z
00233: 0255                    
00234: 0255 83 C4 08    ADD     ESP, 00000008
f_bg_write4(0, f);
printf("   ");
00236: 0258 68 00000000 PUSH    OFFSET .data+00000734
00237: 025D FF 15 00000000 CALL DWORD PTR __imp__printf
00238: 0263                    
00239: 0263 83 C4 04    ADD     ESP, 00000004
00240: 0266 8D 85 FFFFFF64LEA   EAX, DWORD PTR FFFFFF64[EBP]
00241: 026C 89 C1       MOV     ECX, EAX
00242: 026E FF 15 00000000 CALL DWORD PTR __imp_??1BStopWatch@@UAE@XZ
printf("   ");

} // end of recordSoundFrame for CMoteurRecord
00244: 0274     L0000
00245: 0274 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00246: 0277 5F          POP     EDI
00247: 0278 5E          POP     ESI
00248: 0279 5B          POP     EBX
00249: 027A 5D          POP     EBP
00250: 027B C3          RETN    

Function: ??_ERInterface@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 8B 55 08    MOV     EDX, DWORD PTR 00000008[EBP]
00005: 0007 89 CB       MOV     EBX, ECX
00006: 0009 09 DB       OR      EBX, EBX
00007: 000B 74 35       JE      L0001
00008: 000D 89 D0       MOV     EAX, EDX
00009: 000F 25 00000002 AND     EAX, 00000002
00010: 0014 09 C0       OR      EAX, EAX
00011: 0016 74 10       JE      L0002
00012: 0018 68 00000000 PUSH    OFFSET ??1RInterface@@UAE@XZ
00013: 001D 53          PUSH    EBX
00014: 001E E8 00000000 CALL    NEAR PTR ___destroy_new_array
00015: 0023 83 C4 08    ADD     ESP, 00000008
00016: 0026 EB 1A       JMP     L0001
00017: 0028     L0002
00018: 0028 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7RInterface@@6B@+00000008
00019: 002E 89 D0       MOV     EAX, EDX
00020: 0030 25 00000001 AND     EAX, 00000001
00021: 0035 09 C0       OR      EAX, EAX
00022: 0037 74 09       JE      L0001
00023: 0039 53          PUSH    EBX
00024: 003A E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00025: 003F 83 C4 04    ADD     ESP, 00000004
00026: 0042     L0001
00027: 0042 89 D8       MOV     EAX, EBX
00028: 0044     L0000
00029: 0044 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00030: 0047 5B          POP     EBX
00031: 0048 5D          POP     EBP
00032: 0049 C3          RETN    

Function: ??_ECMoteurDocument@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 8B 45 08    MOV     EAX, DWORD PTR 00000008[EBP]
00005: 0007 89 CB       MOV     EBX, ECX
00006: 0009 09 DB       OR      EBX, EBX
00007: 000B 74 58       JE      L0001
00008: 000D 89 C2       MOV     EDX, EAX
00009: 000F 81 E2 00000002 AND  EDX, 00000002
00010: 0015 09 D2       OR      EDX, EDX
00011: 0017 74 10       JE      L0002
00012: 0019 68 00000000 PUSH    OFFSET ??_DCMoteurDocument@@UAE@XZ
00013: 001E 53          PUSH    EBX
00014: 001F E8 00000000 CALL    NEAR PTR ___destroy_new_array
00015: 0024 83 C4 08    ADD     ESP, 00000008
00016: 0027 EB 3C       JMP     L0001
00017: 0029     L0002
00018: 0029 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7CMoteurDocument@@6B@+00000008
00019: 002F 8B 53 04    MOV     EDX, DWORD PTR 00000004[EBX]
00020: 0032 C7 02 00000014 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7CMoteurDocument@@6B@+00000014
00021: 0038 C7 43 08 00000000 MOV DWORD PTR 00000008[EBX], 00000000
00022: 003F C7 43 0C 00000000 MOV DWORD PTR 0000000C[EBX], 00000000
00023: 0046 C7 43 10 00000008 MOV DWORD PTR 00000010[EBX], OFFSET ??_7RInterface@@6B@+00000008
00024: 004D             NOOP    
00025: 004D 8D 53 10    LEA     EDX, DWORD PTR 00000010[EBX]
00026: 0050 89 C2       MOV     EDX, EAX
00027: 0052 81 E2 00000001 AND  EDX, 00000001
00028: 0058 09 D2       OR      EDX, EDX
00029: 005A 74 09       JE      L0001
00030: 005C 53          PUSH    EBX
00031: 005D E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00032: 0062 83 C4 04    ADD     ESP, 00000004
00033: 0065     L0001
00034: 0065 89 D8       MOV     EAX, EBX
00035: 0067     L0000
00036: 0067 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00037: 006A 5B          POP     EBX
00038: 006B 5D          POP     EBP
00039: 006C C3          RETN    

Function: ??_DCMoteurDocument@@UAE@XZ
00001: 0000 89 CA       MOV     EDX, ECX
00002: 0002 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7CMoteurDocument@@6B@+00000008
00003: 0008 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00004: 000B C7 00 00000014 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7CMoteurDocument@@6B@+00000014
00005: 0011 C7 42 08 00000000 MOV DWORD PTR 00000008[EDX], 00000000
00006: 0018 C7 42 0C 00000000 MOV DWORD PTR 0000000C[EDX], 00000000
00007: 001F C7 42 10 00000008 MOV DWORD PTR 00000010[EDX], OFFSET ??_7RInterface@@6B@+00000008
00008: 0026             NOOP    
00009: 0026 8D 42 10    LEA     EAX, DWORD PTR 00000010[EDX]
00010: 0029 89 D0       MOV     EAX, EDX
00011: 002B     L0000
00012: 002B C3          RETN    

Function: ??_E?$TRotateBuffer@PAVRBitmap@@@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 56          PUSH    ESI
00005: 0005 57          PUSH    EDI
00006: 0006 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00007: 0009 89 CE       MOV     ESI, ECX
00008: 000B 09 F6       OR      ESI, ESI
00009: 000D 0F 84 00000091 JE   L0001
00010: 0013 89 D8       MOV     EAX, EBX
00011: 0015 25 00000002 AND     EAX, 00000002
00012: 001A 09 C0       OR      EAX, EAX
00013: 001C 74 10       JE      L0002
00014: 001E 68 00000000 PUSH    OFFSET ??1?$TRotateBuffer@PAVRBitmap@@@@UAE@XZ
00015: 0023 56          PUSH    ESI
00016: 0024 E8 00000000 CALL    NEAR PTR ___destroy_new_array
00017: 0029 83 C4 08    ADD     ESP, 00000008
00018: 002C EB 76       JMP     L0001
00019: 002E     L0002
00020: 002E C7 06 00000008 MOV  DWORD PTR 00000000[ESI], OFFSET ??_7?$TRotateBuffer@PAVRBitmap@@@@6B@+00000008
00021: 0034 89 F1       MOV     ECX, ESI
00022: 0036 E8 00000000 CALL    NEAR PTR ?makeEmpty@?$TRotateBuffer@PAVRBitmap@@@@IAEXXZ
00023: 003B C7 46 04 00000000 MOV DWORD PTR 00000004[ESI], 00000000
00024: 0042             NOOP    
00025: 0042 8D 46 24    LEA     EAX, DWORD PTR 00000024[ESI]
00026: 0045 89 C1       MOV     ECX, EAX
00027: 0047 E8 00000000 CALL    NEAR PTR ??1RSem@@UAE@XZ
00028: 004C BF 00000008 MOV     EDI, OFFSET ??_7RInterface@@6B@+00000008
00029: 0051 89 7E 30    MOV     DWORD PTR 00000030[ESI], EDI
00030: 0054             NOOP    
00031: 0054 8D 46 24    LEA     EAX, DWORD PTR 00000024[ESI]
00032: 0057 05 0000000C ADD     EAX, 0000000C
00033: 005C             NOOP    
00034: 005C 8D 46 24    LEA     EAX, DWORD PTR 00000024[ESI]
00035: 005F C7 46 08 00000008 MOV DWORD PTR 00000008[ESI], OFFSET ??_7?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@6B@+00000008
00036: 0066 83 7E 18 00 CMP     DWORD PTR 00000018[ESI], 00000000
00037: 006A 74 0C       JE      L0003
00038: 006C 8B 46 18    MOV     EAX, DWORD PTR 00000018[ESI]
00039: 006F 50          PUSH    EAX
00040: 0070 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00041: 0075 83 C4 04    ADD     ESP, 00000004
00042: 0078     L0003
00043: 0078 C7 46 14 00000000 MOV DWORD PTR 00000014[ESI], 00000000
00044: 007F 8B 46 14    MOV     EAX, DWORD PTR 00000014[ESI]
00045: 0082 89 46 10    MOV     DWORD PTR 00000010[ESI], EAX
00046: 0085 89 7E 08    MOV     DWORD PTR 00000008[ESI], EDI
00047: 0088             NOOP    
00048: 0088 8D 46 08    LEA     EAX, DWORD PTR 00000008[ESI]
00049: 008B             NOOP    
00050: 008B 8D 46 08    LEA     EAX, DWORD PTR 00000008[ESI]
00051: 008E 89 3E       MOV     DWORD PTR 00000000[ESI], EDI
00052: 0090 89 D8       MOV     EAX, EBX
00053: 0092 25 00000001 AND     EAX, 00000001
00054: 0097 09 C0       OR      EAX, EAX
00055: 0099 74 09       JE      L0001
00056: 009B 56          PUSH    ESI
00057: 009C E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00058: 00A1 83 C4 04    ADD     ESP, 00000004
00059: 00A4     L0001
00060: 00A4 89 F0       MOV     EAX, ESI
00061: 00A6     L0000
00062: 00A6 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00063: 00A9 5F          POP     EDI
00064: 00AA 5E          POP     ESI
00065: 00AB 5B          POP     EBX
00066: 00AC 5D          POP     EBP
00067: 00AD C3          RETN    

Function: ??_E?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 56          PUSH    ESI
00005: 0005 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00006: 0008 89 CE       MOV     ESI, ECX
00007: 000A 09 F6       OR      ESI, ESI
00008: 000C 74 58       JE      L0001
00009: 000E 89 D8       MOV     EAX, EBX
00010: 0010 25 00000002 AND     EAX, 00000002
00011: 0015 09 C0       OR      EAX, EAX
00012: 0017 74 10       JE      L0002
00013: 0019 68 00000000 PUSH    OFFSET ??1?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@UAE@XZ
00014: 001E 56          PUSH    ESI
00015: 001F E8 00000000 CALL    NEAR PTR ___destroy_new_array
00016: 0024 83 C4 08    ADD     ESP, 00000008
00017: 0027 EB 3D       JMP     L0001
00018: 0029     L0002
00019: 0029 C7 06 00000008 MOV  DWORD PTR 00000000[ESI], OFFSET ??_7?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@6B@+00000008
00020: 002F 8B 46 10    MOV     EAX, DWORD PTR 00000010[ESI]
00021: 0032 09 C0       OR      EAX, EAX
00022: 0034 74 09       JE      L0003
00023: 0036 50          PUSH    EAX
00024: 0037 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00025: 003C 83 C4 04    ADD     ESP, 00000004
00026: 003F     L0003
00027: 003F C7 46 0C 00000000 MOV DWORD PTR 0000000C[ESI], 00000000
00028: 0046 8B 46 0C    MOV     EAX, DWORD PTR 0000000C[ESI]
00029: 0049 89 46 08    MOV     DWORD PTR 00000008[ESI], EAX
00030: 004C C7 06 00000008 MOV  DWORD PTR 00000000[ESI], OFFSET ??_7RInterface@@6B@+00000008
00031: 0052 89 D8       MOV     EAX, EBX
00032: 0054 25 00000001 AND     EAX, 00000001
00033: 0059 09 C0       OR      EAX, EAX
00034: 005B 74 09       JE      L0001
00035: 005D 56          PUSH    ESI
00036: 005E E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00037: 0063 83 C4 04    ADD     ESP, 00000004
00038: 0066     L0001
00039: 0066 89 F0       MOV     EAX, ESI
00040: 0068     L0000
00041: 0068 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00042: 006B 5E          POP     ESI
00043: 006C 5B          POP     EBX
00044: 006D 5D          POP     EBP
00045: 006E C3          RETN    

Function: ??_ERPath@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 56          PUSH    ESI
00005: 0005 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00006: 0008 89 CE       MOV     ESI, ECX
00007: 000A 09 F6       OR      ESI, ESI
00008: 000C 74 50       JE      L0001
00009: 000E 89 D8       MOV     EAX, EBX
00010: 0010 25 00000002 AND     EAX, 00000002
00011: 0015 09 C0       OR      EAX, EAX
00012: 0017 74 10       JE      L0002
00013: 0019 68 00000000 PUSH    OFFSET ??_DRPath@@UAE@XZ
00014: 001E 56          PUSH    ESI
00015: 001F E8 00000000 CALL    NEAR PTR ___destroy_new_array
00016: 0024 83 C4 08    ADD     ESP, 00000008
00017: 0027 EB 35       JMP     L0001
00018: 0029     L0002
00019: 0029 C7 06 00000008 MOV  DWORD PTR 00000000[ESI], OFFSET ??_7RPath@@6B@+00000008
00020: 002F 8B 46 1C    MOV     EAX, DWORD PTR 0000001C[ESI]
00022: 0032 89 F1       MOV     ECX, ESI
00021: 0034 C7 00 00000044 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7RPath@@6B@+00000044
00023: 003A FF 15 00000000 CALL DWORD PTR __imp_??1BPath@@UAE@XZ
00024: 0040 C7 46 20 00000008 MOV DWORD PTR 00000020[ESI], OFFSET ??_7RInterface@@6B@+00000008
00025: 0047             NOOP    
00026: 0047 8D 46 20    LEA     EAX, DWORD PTR 00000020[ESI]
00027: 004A 89 D8       MOV     EAX, EBX
00028: 004C 25 00000001 AND     EAX, 00000001
00029: 0051 09 C0       OR      EAX, EAX
00030: 0053 74 09       JE      L0001
00031: 0055 56          PUSH    ESI
00032: 0056 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00033: 005B 83 C4 04    ADD     ESP, 00000004
00034: 005E     L0001
00035: 005E 89 F0       MOV     EAX, ESI
00036: 0060     L0000
00037: 0060 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00038: 0063 5E          POP     ESI
00039: 0064 5B          POP     EBX
00040: 0065 5D          POP     EBP
00041: 0066 C3          RETN    

Function: ??_E?$TQList@PAUSSoundBuffer@@@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 56          PUSH    ESI
00005: 0005 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00006: 0008 89 CE       MOV     ESI, ECX
00007: 000A 09 F6       OR      ESI, ESI
00008: 000C 74 4F       JE      L0001
00009: 000E 89 D8       MOV     EAX, EBX
00010: 0010 25 00000002 AND     EAX, 00000002
00011: 0015 09 C0       OR      EAX, EAX
00012: 0017 74 10       JE      L0002
00013: 0019 68 00000000 PUSH    OFFSET ??1?$TQList@PAUSSoundBuffer@@@@UAE@XZ
00014: 001E 56          PUSH    ESI
00015: 001F E8 00000000 CALL    NEAR PTR ___destroy_new_array
00016: 0024 83 C4 08    ADD     ESP, 00000008
00017: 0027 EB 34       JMP     L0001
00018: 0029     L0002
00019: 0029 C7 06 00000008 MOV  DWORD PTR 00000000[ESI], OFFSET ??_7?$TQList@PAUSSoundBuffer@@@@6B@+00000008
00020: 002F EB 07       JMP     L0003
00021: 0031     L0004
00022: 0031 89 F1       MOV     ECX, ESI
00023: 0033 E8 00000000 CALL    NEAR PTR ?removeFirst@?$TQList@PAUSSoundBuffer@@@@QAEPAUSSoundBuffer@@XZ
00024: 0038     L0003
00025: 0038 83 7E 08 00 CMP     DWORD PTR 00000008[ESI], 00000000
00026: 003C 0F 94 C0    SETE    AL
00027: 003F 08 C0       OR      AL, AL
00028: 0041 74 EE       JE      L0004
00029: 0043 C7 06 00000008 MOV  DWORD PTR 00000000[ESI], OFFSET ??_7RInterface@@6B@+00000008
00030: 0049 89 D8       MOV     EAX, EBX
00031: 004B 25 00000001 AND     EAX, 00000001
00032: 0050 09 C0       OR      EAX, EAX
00033: 0052 74 09       JE      L0001
00034: 0054 56          PUSH    ESI
00035: 0055 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00036: 005A 83 C4 04    ADD     ESP, 00000004
00037: 005D     L0001
00038: 005D 89 F0       MOV     EAX, ESI
00039: 005F     L0000
00040: 005F 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00041: 0062 5E          POP     ESI
00042: 0063 5B          POP     EBX
00043: 0064 5D          POP     EBP
00044: 0065 C3          RETN    

Function: ??_ECMoteurRecord@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 56          PUSH    ESI
00005: 0005 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00006: 0008 89 CE       MOV     ESI, ECX
00007: 000A 09 F6       OR      ESI, ESI
00008: 000C 74 46       JE      L0001
00009: 000E 89 D8       MOV     EAX, EBX
00010: 0010 25 00000002 AND     EAX, 00000002
00011: 0015 09 C0       OR      EAX, EAX
00012: 0017 74 10       JE      L0002
00013: 0019 68 00000000 PUSH    OFFSET ??_DCMoteurRecord@@UAE@XZ
00014: 001E 56          PUSH    ESI
00015: 001F E8 00000000 CALL    NEAR PTR ___destroy_new_array
00016: 0024 83 C4 08    ADD     ESP, 00000008
00017: 0027 EB 2B       JMP     L0001
00018: 0029     L0002
00019: 0029 89 F1       MOV     ECX, ESI
00020: 002B E8 00000000 CALL    NEAR PTR ??1CMoteurRecord@@UAE@XZ
00021: 0030 C7 86 0000013400000008 MOV DWORD PTR 00000134[ESI], OFFSET ??_7RInterface@@6B@+00000008
00022: 003A             NOOP    
00023: 003A 8D 86 00000134LEA   EAX, DWORD PTR 00000134[ESI]
00024: 0040 89 D8       MOV     EAX, EBX
00025: 0042 25 00000001 AND     EAX, 00000001
00026: 0047 09 C0       OR      EAX, EAX
00027: 0049 74 09       JE      L0001
00028: 004B 56          PUSH    ESI
00029: 004C E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00030: 0051 83 C4 04    ADD     ESP, 00000004
00031: 0054     L0001
00032: 0054 89 F0       MOV     EAX, ESI
00033: 0056     L0000
00034: 0056 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00035: 0059 5E          POP     ESI
00036: 005A 5B          POP     EBX
00037: 005B 5D          POP     EBP
00038: 005C C3          RETN    

Function: ??_DCMoteurRecord@@UAE@XZ
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 89 CB       MOV     EBX, ECX
00005: 0006 E8 00000000 CALL    NEAR PTR ??1CMoteurRecord@@UAE@XZ
00006: 000B C7 83 0000013400000008 MOV DWORD PTR 00000134[EBX], OFFSET ??_7RInterface@@6B@+00000008
00007: 0015             NOOP    
00008: 0015 8D 83 00000134LEA   EAX, DWORD PTR 00000134[EBX]
00009: 001B 89 D8       MOV     EAX, EBX
00010: 001D     L0000
00011: 001D 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00012: 0020 5B          POP     EBX
00013: 0021 5D          POP     EBP
00014: 0022 C3          RETN    

Function: ??_ERRect@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 8B 45 08    MOV     EAX, DWORD PTR 00000008[EBP]
00005: 0007 89 CB       MOV     EBX, ECX
00006: 0009 09 DB       OR      EBX, EBX
00007: 000B 74 4A       JE      L0001
00008: 000D 89 C2       MOV     EDX, EAX
00009: 000F 81 E2 00000002 AND  EDX, 00000002
00010: 0015 09 D2       OR      EDX, EDX
00011: 0017 74 10       JE      L0002
00012: 0019 68 00000000 PUSH    OFFSET ??_DRRect@@UAE@XZ
00013: 001E 53          PUSH    EBX
00014: 001F E8 00000000 CALL    NEAR PTR ___destroy_new_array
00015: 0024 83 C4 08    ADD     ESP, 00000008
00016: 0027 EB 2E       JMP     L0001
00017: 0029     L0002
00018: 0029 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7RRect@@6B@+00000008
00019: 002F 8B 53 04    MOV     EDX, DWORD PTR 00000004[EBX]
00020: 0032 C7 02 00000014 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7RRect@@6B@+00000014
00021: 0038 C7 43 18 00000008 MOV DWORD PTR 00000018[EBX], OFFSET ??_7RInterface@@6B@+00000008
00022: 003F             NOOP    
00023: 003F 8D 53 18    LEA     EDX, DWORD PTR 00000018[EBX]
00024: 0042 89 C2       MOV     EDX, EAX
00025: 0044 81 E2 00000001 AND  EDX, 00000001
00026: 004A 09 D2       OR      EDX, EDX
00027: 004C 74 09       JE      L0001
00028: 004E 53          PUSH    EBX
00029: 004F E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00030: 0054 83 C4 04    ADD     ESP, 00000004
00031: 0057     L0001
00032: 0057 89 D8       MOV     EAX, EBX
00033: 0059     L0000
00034: 0059 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00035: 005C 5B          POP     EBX
00036: 005D 5D          POP     EBP
00037: 005E C3          RETN    

Function: ??1SSoundBuffer@@QAE@XZ
{ if (mBuffer) delete mBuffer; }
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 89 CB       MOV     EBX, ECX
if (mBuffer) delete mBuffer; }
00007: 0006 8B 43 04    MOV     EAX, DWORD PTR 00000004[EBX]
00008: 0009 09 C0       OR      EAX, EAX
00009: 000B 74 09       JE      L0001
delete mBuffer; }
00011: 000D 50          PUSH    EAX
00012: 000E E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00013: 0013 83 C4 04    ADD     ESP, 00000004
00014: 0016     L0001
00015: 0016 89 D8       MOV     EAX, EBX
00016: 0018     L0000
00017: 0018 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00018: 001B 5B          POP     EBX
00019: 001C 5D          POP     EBP
00020: 001D C3          RETN    

Function: ?bounds@RBitmap@@QAE?AVRRect@@XZ
{ return mBounds; 			 }
00002: 0000 55          PUSH    EBP
00004: 0001 89 C8       MOV     EAX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
return mBounds; 			 }
00006: 0005 8B 55 08    MOV     EDX, DWORD PTR 00000008[EBP]
00007: 0008             NOOP    
00008: 0008 8D 4A 18    LEA     ECX, DWORD PTR 00000018[EDX]
00009: 000B 89 4A 04    MOV     DWORD PTR 00000004[EDX], ECX
00010: 000E C7 42 18 00000008 MOV DWORD PTR 00000018[EDX], OFFSET ??_7RInterface@@6B@+00000008
00011: 0015             NOOP    
00012: 0015 8D 4A 18    LEA     ECX, DWORD PTR 00000018[EDX]
00013: 0018 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7RRect@@6B@+00000008
00014: 001E 8B 4A 04    MOV     ECX, DWORD PTR 00000004[EDX]
00015: 0021 C7 01 00000014 MOV  DWORD PTR 00000000[ECX], OFFSET ??_7RRect@@6B@+00000014
00016: 0027 8B 48 10    MOV     ECX, DWORD PTR 00000010[EAX]
00017: 002A 89 4A 08    MOV     DWORD PTR 00000008[EDX], ECX
00018: 002D 8B 48 14    MOV     ECX, DWORD PTR 00000014[EAX]
00019: 0030 89 4A 0C    MOV     DWORD PTR 0000000C[EDX], ECX
00020: 0033 8B 48 18    MOV     ECX, DWORD PTR 00000018[EAX]
00021: 0036 89 4A 10    MOV     DWORD PTR 00000010[EDX], ECX
00022: 0039 8B 48 1C    MOV     ECX, DWORD PTR 0000001C[EAX]
00023: 003C 89 4A 14    MOV     DWORD PTR 00000014[EDX], ECX
00024: 003F 8B 45 08    MOV     EAX, DWORD PTR 00000008[EBP]
00025: 0042     L0000
00026: 0042 C9          LEAVE   
00027: 0043 C3          RETN    

Function: ?release@RSem@@QAEXXZ
{
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
if (mId != -1) release_sem(mId);
00006: 0005 83 7A 08 FF CMP     DWORD PTR 00000008[EDX], FFFFFFFF
00007: 0009 74 0D       JE      L0001
release_sem(mId);
00009: 000B 8B 42 08    MOV     EAX, DWORD PTR 00000008[EDX]
00010: 000E 50          PUSH    EAX
00011: 000F FF 15 00000000 CALL DWORD PTR __imp__release_sem
00012: 0015 83 C4 04    ADD     ESP, 00000004
00013: 0018     L0001
} // end of sleep for RSem
00015: 0018     L0000
00016: 0018 C9          LEAVE   
00017: 0019 C3          RETN    

Function: ?itemAt@?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@QAEPAU?$SRotateItem@PAVRBitmap@@@@J@Z
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 8B 55 08    MOV     EDX, DWORD PTR 00000008[EBP]
00006: 0007 89 CB       MOV     EBX, ECX
if (mListe && index < mTaille) return mListe[index];
00008: 0009 8B 4B 10    MOV     ECX, DWORD PTR 00000010[EBX]
00009: 000C 09 C9       OR      ECX, ECX
00010: 000E 74 0E       JE      L0001
00011: 0010 3B 53 08    CMP     EDX, DWORD PTR 00000008[EBX]
00012: 0013 7D 09       JGE     L0001
return mListe[index];
00014: 0015 8B 04 91    MOV     EAX, DWORD PTR 00000000[ECX][EDX*4]
00015: 0018 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00016: 001B 5B          POP     EBX
00017: 001C 5D          POP     EBP
00018: 001D C3          RETN    
00019: 001E     L0001
return NULL;
00021: 001E 31 C0       XOR     EAX, EAX
00022: 0020     L0000
00023: 0020 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00024: 0023 5B          POP     EBX
00025: 0024 5D          POP     EBP
00026: 0025 C3          RETN    

Function: ?acquire@RSem@@QAEXXZ
{
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
if (mId != -1) acquire_sem(mId);
00006: 0005 83 7A 08 FF CMP     DWORD PTR 00000008[EDX], FFFFFFFF
00007: 0009 74 0D       JE      L0001
acquire_sem(mId);
00009: 000B 8B 42 08    MOV     EAX, DWORD PTR 00000008[EDX]
00010: 000E 50          PUSH    EAX
00011: 000F FF 15 00000000 CALL DWORD PTR __imp__acquire_sem
00012: 0015 83 C4 04    ADD     ESP, 00000004
00013: 0018     L0001
} // end of acquire for RSem
00015: 0018     L0000
00016: 0018 C9          LEAVE   
00017: 0019 C3          RETN    

Function: ??_DRRect@@UAE@XZ
00001: 0000 89 CA       MOV     EDX, ECX
00002: 0002 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7RRect@@6B@+00000008
00003: 0008 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00004: 000B C7 00 00000014 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7RRect@@6B@+00000014
00005: 0011 C7 42 18 00000008 MOV DWORD PTR 00000018[EDX], OFFSET ??_7RInterface@@6B@+00000008
00006: 0018             NOOP    
00007: 0018 8D 42 18    LEA     EAX, DWORD PTR 00000018[EDX]
00008: 001B 89 D0       MOV     EAX, EDX
00009: 001D     L0000
00010: 001D C3          RETN    

Function: ??_ERErrEx@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 8B 55 08    MOV     EDX, DWORD PTR 00000008[EBP]
00005: 0007 89 CB       MOV     EBX, ECX
00006: 0009 09 DB       OR      EBX, EBX
00007: 000B 74 35       JE      L0001
00008: 000D 89 D0       MOV     EAX, EDX
00009: 000F 25 00000002 AND     EAX, 00000002
00010: 0014 09 C0       OR      EAX, EAX
00011: 0016 74 10       JE      L0002
00012: 0018 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00013: 001D 53          PUSH    EBX
00014: 001E E8 00000000 CALL    NEAR PTR ___destroy_new_array
00015: 0023 83 C4 08    ADD     ESP, 00000008
00016: 0026 EB 1A       JMP     L0001
00017: 0028     L0002
00018: 0028 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7RErrEx@@6B@+00000008
00019: 002E 89 D0       MOV     EAX, EDX
00020: 0030 25 00000001 AND     EAX, 00000001
00021: 0035 09 C0       OR      EAX, EAX
00022: 0037 74 09       JE      L0001
00023: 0039 53          PUSH    EBX
00024: 003A E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00025: 003F 83 C4 04    ADD     ESP, 00000004
00026: 0042     L0001
00027: 0042 89 D8       MOV     EAX, EBX
00028: 0044     L0000
00029: 0044 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00030: 0047 5B          POP     EBX
00031: 0048 5D          POP     EBP
00032: 0049 C3          RETN    

Function: ?soundDeviceOpen@RSoundRecord@@UAEEXZ
{ return mUseSound; }
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
return mUseSound; }
00006: 0005 8A 42 04    MOV     AL, BYTE PTR 00000004[EDX]
00007: 0008     L0000
00008: 0008 C9          LEAVE   
00009: 0009 C3          RETN    

Function: ?makeEmpty@?$TRotateBuffer@PAVRBitmap@@@@IAEXXZ
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 89 CB       MOV     EBX, ECX
if (!mNbBuffer) return;
00008: 0007 83 7B 04 00 CMP     DWORD PTR 00000004[EBX], 00000000
00009: 000B 75 07       JNE     L0001
return;
00011: 000D 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00012: 0010 5E          POP     ESI
00013: 0011 5B          POP     EBX
00014: 0012 5D          POP     EBP
00015: 0013 C3          RETN    
00016: 0014     L0001
mNbBuffer = 0;
00018: 0014 C7 43 04 00000000 MOV DWORD PTR 00000004[EBX], 00000000
mCurrentRead = mCurrentWrite = 0;
00020: 001B C7 43 20 00000000 MOV DWORD PTR 00000020[EBX], 00000000
00021: 0022 8B 43 20    MOV     EAX, DWORD PTR 00000020[EBX]
00022: 0025 89 43 1C    MOV     DWORD PTR 0000001C[EBX], EAX
while((item = mBufferList.removeLastItem()) != NULL) delete item;
00024: 0028 EB 09       JMP     L0002
00025: 002A     L0003
delete item;
00027: 002A 56          PUSH    ESI
00028: 002B E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00029: 0030 83 C4 04    ADD     ESP, 00000004
00030: 0033     L0002
00031: 0033 83 7B 18 00 CMP     DWORD PTR 00000018[EBX], 00000000
00032: 0037 74 06       JE      L0004
00033: 0039 83 7B 10 01 CMP     DWORD PTR 00000010[EBX], 00000001
00034: 003D 7D 04       JGE     L0005
00035: 003F     L0004
00036: 003F 31 F6       XOR     ESI, ESI
00037: 0041 EB 2F       JMP     L0006
00038: 0043     L0005
00039: 0043 FF 4B 10    DEC     DWORD PTR 00000010[EBX]
00040: 0046 8B 53 18    MOV     EDX, DWORD PTR 00000018[EBX]
00041: 0049 8B 43 10    MOV     EAX, DWORD PTR 00000010[EBX]
00043: 004C 83 7B 10 00 CMP     DWORD PTR 00000010[EBX], 00000000
00042: 0050 8B 34 82    MOV     ESI, DWORD PTR 00000000[EDX][EAX*4]
00044: 0053 75 1D       JNE     L0007
00045: 0055 09 D2       OR      EDX, EDX
00046: 0057 74 0C       JE      L0008
00047: 0059 8B 43 18    MOV     EAX, DWORD PTR 00000018[EBX]
00048: 005C 50          PUSH    EAX
00049: 005D E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00050: 0062 83 C4 04    ADD     ESP, 00000004
00051: 0065     L0008
00052: 0065 C7 43 14 00000000 MOV DWORD PTR 00000014[EBX], 00000000
00053: 006C 8B 43 14    MOV     EAX, DWORD PTR 00000014[EBX]
00054: 006F 89 43 10    MOV     DWORD PTR 00000010[EBX], EAX
00055: 0072     L0007
00056: 0072             NOOP    
00057: 0072     L0006
00058: 0072 89 F0       MOV     EAX, ESI
00059: 0074 09 F0       OR      EAX, ESI
00060: 0076 75 B2       JNE     L0003
} // end of makeEmpty for TRotateBuffer< PV >
00062: 0078     L0000
00063: 0078 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00064: 007B 5E          POP     ESI
00065: 007C 5B          POP     EBX
00066: 007D 5D          POP     EBP
00067: 007E C3          RETN    

Function: ?removeFirst@?$TQList@PAUSSoundBuffer@@@@QAEPAUSSoundBuffer@@XZ
{
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
if (!mHead) return NULL;
00006: 0005 8B 4A 08    MOV     ECX, DWORD PTR 00000008[EDX]
00007: 0008 09 C9       OR      ECX, ECX
00008: 000A 75 04       JNE     L0001
return NULL;
00010: 000C 31 C0       XOR     EAX, EAX
00011: 000E C9          LEAVE   
00012: 000F C3          RETN    
00013: 0010     L0001
mHead = (PV)mHead->mNext;
00015: 0010 8B 42 08    MOV     EAX, DWORD PTR 00000008[EDX]
00016: 0013 8B 00       MOV     EAX, DWORD PTR 00000000[EAX]
00017: 0015 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
if (!mHead) mQueue = NULL;
00019: 0018 83 7A 08 00 CMP     DWORD PTR 00000008[EDX], 00000000
00020: 001C 75 07       JNE     L0002
mQueue = NULL;
00022: 001E C7 42 0C 00000000 MOV DWORD PTR 0000000C[EDX], 00000000
00023: 0025     L0002
mTaille--;
00025: 0025 FF 4A 04    DEC     DWORD PTR 00000004[EDX]
return p;
00027: 0028 89 C8       MOV     EAX, ECX
00028: 002A     L0000
00029: 002A C9          LEAVE   
00030: 002B C3          RETN    

Function: ??_ERBitmap@@UAE@I@Z
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 56          PUSH    ESI
00005: 0005 8B 5D 08    MOV     EBX, DWORD PTR 00000008[EBP]
00006: 0008 89 CE       MOV     ESI, ECX
00007: 000A 09 F6       OR      ESI, ESI
00008: 000C 74 40       JE      L0001
00009: 000E 89 D8       MOV     EAX, EBX
00010: 0010 25 00000002 AND     EAX, 00000002
00011: 0015 09 C0       OR      EAX, EAX
00012: 0017 74 10       JE      L0002
00013: 0019 68 00000000 PUSH    OFFSET ??_DRBitmap@@UAE@XZ
00014: 001E 56          PUSH    ESI
00015: 001F E8 00000000 CALL    NEAR PTR ___destroy_new_array
00016: 0024 83 C4 08    ADD     ESP, 00000008
00017: 0027 EB 25       JMP     L0001
00018: 0029     L0002
00019: 0029 89 F1       MOV     ECX, ESI
00020: 002B E8 00000000 CALL    NEAR PTR ??1RBitmap@@UAE@XZ
00021: 0030 C7 46 5C 00000008 MOV DWORD PTR 0000005C[ESI], OFFSET ??_7RInterface@@6B@+00000008
00022: 0037             NOOP    
00023: 0037 8D 46 5C    LEA     EAX, DWORD PTR 0000005C[ESI]
00024: 003A 89 D8       MOV     EAX, EBX
00025: 003C 25 00000001 AND     EAX, 00000001
00026: 0041 09 C0       OR      EAX, EAX
00027: 0043 74 09       JE      L0001
00028: 0045 56          PUSH    ESI
00029: 0046 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00030: 004B 83 C4 04    ADD     ESP, 00000004
00031: 004E     L0001
00032: 004E 89 F0       MOV     EAX, ESI
00033: 0050     L0000
00034: 0050 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00035: 0053 5E          POP     ESI
00036: 0054 5B          POP     EBX
00037: 0055 5D          POP     EBP
00038: 0056 C3          RETN    

Function: ??_DRBitmap@@UAE@XZ
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 89 CB       MOV     EBX, ECX
00005: 0006 E8 00000000 CALL    NEAR PTR ??1RBitmap@@UAE@XZ
00006: 000B C7 43 5C 00000008 MOV DWORD PTR 0000005C[EBX], OFFSET ??_7RInterface@@6B@+00000008
00007: 0012             NOOP    
00008: 0012 8D 43 5C    LEA     EAX, DWORD PTR 0000005C[EBX]
00009: 0015 89 D8       MOV     EAX, EBX
00010: 0017     L0000
00011: 0017 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00012: 001A 5B          POP     EBX
00013: 001B 5D          POP     EBP
00014: 001C C3          RETN    

Function: ??1RErrEx@@UAE@XZ
{ }
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
00005: 0005 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7RErrEx@@6B@+00000008
00006: 000B 89 D0       MOV     EAX, EDX
00007: 000D     L0000
00008: 000D C9          LEAVE   
00009: 000E C3          RETN    

Function: ??1CSoundRecord@@UAE@XZ
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 89 CB       MOV     EBX, ECX
00005: 0006 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7CSoundRecord@@6B@+00000008
00006: 000C E8 00000000 CALL    NEAR PTR ??1RSoundRecord@@UAE@XZ
00007: 0011 89 D8       MOV     EAX, EBX
00008: 0013     L0000
00009: 0013 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00010: 0016 5B          POP     EBX
00011: 0017 5D          POP     EBP
00012: 0018 C3          RETN    

Function: ??1SSharedSoundBuffer@@QAE@XZ
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 56          PUSH    ESI
00005: 0005 89 CB       MOV     EBX, ECX
00006: 0007             NOOP    
00007: 0007 8D 43 10    LEA     EAX, DWORD PTR 00000010[EBX]
00008: 000A 89 C1       MOV     ECX, EAX
00009: 000C E8 00000000 CALL    NEAR PTR ??1RSem@@UAE@XZ
00010: 0011 BE 00000008 MOV     ESI, OFFSET ??_7RInterface@@6B@+00000008
00011: 0016 89 73 1C    MOV     DWORD PTR 0000001C[EBX], ESI
00012: 0019             NOOP    
00013: 0019 8D 43 10    LEA     EAX, DWORD PTR 00000010[EBX]
00014: 001C 05 0000000C ADD     EAX, 0000000C
00015: 0021             NOOP    
00016: 0021 8D 43 10    LEA     EAX, DWORD PTR 00000010[EBX]
00017: 0024 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7?$TQList@PAUSSoundBuffer@@@@6B@+00000008
00018: 002A EB 07       JMP     L0001
00019: 002C     L0002
00020: 002C 89 D9       MOV     ECX, EBX
00021: 002E E8 00000000 CALL    NEAR PTR ?removeFirst@?$TQList@PAUSSoundBuffer@@@@QAEPAUSSoundBuffer@@XZ
00022: 0033     L0001
00023: 0033 83 7B 08 00 CMP     DWORD PTR 00000008[EBX], 00000000
00024: 0037 0F 94 C0    SETE    AL
00025: 003A 08 C0       OR      AL, AL
00026: 003C 74 EE       JE      L0002
00027: 003E 89 33       MOV     DWORD PTR 00000000[EBX], ESI
00028: 0040 89 D8       MOV     EAX, EBX
00029: 0042     L0000
00030: 0042 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00031: 0045 5E          POP     ESI
00032: 0046 5B          POP     EBX
00033: 0047 5D          POP     EBP
00034: 0048 C3          RETN    

Function: ??1?$TQList@PAUSSoundBuffer@@@@UAE@XZ
{
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
00005: 0005 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7?$TQList@PAUSSoundBuffer@@@@6B@+00000008
makeEmpty();
00007: 000B EB 1C       JMP     L0001
00008: 000D     L0002
00009: 000D 09 C9       OR      ECX, ECX
00010: 000F 74 18       JE      L0003
00011: 0011 8B 42 08    MOV     EAX, DWORD PTR 00000008[EDX]
00012: 0014 8B 00       MOV     EAX, DWORD PTR 00000000[EAX]
00013: 0016 89 42 08    MOV     DWORD PTR 00000008[EDX], EAX
00014: 0019 83 7A 08 00 CMP     DWORD PTR 00000008[EDX], 00000000
00015: 001D 75 07       JNE     L0004
00016: 001F C7 42 0C 00000000 MOV DWORD PTR 0000000C[EDX], 00000000
00017: 0026     L0004
00018: 0026 FF 4A 04    DEC     DWORD PTR 00000004[EDX]
00019: 0029     L0003
00020: 0029     L0001
00021: 0029 8B 4A 08    MOV     ECX, DWORD PTR 00000008[EDX]
00022: 002C 09 C9       OR      ECX, ECX
00023: 002E 0F 94 C0    SETE    AL
00024: 0031 08 C0       OR      AL, AL
00025: 0033 74 D8       JE      L0002
00026: 0035 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7RInterface@@6B@+00000008
00027: 003B 89 D0       MOV     EAX, EDX
00028: 003D     L0000
00029: 003D C9          LEAVE   
00030: 003E C3          RETN    

Function: ??_DRPath@@UAE@XZ
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 89 CB       MOV     EBX, ECX
00005: 0006 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7RPath@@6B@+00000008
00006: 000C 8B 43 1C    MOV     EAX, DWORD PTR 0000001C[EBX]
00007: 000F C7 00 00000044 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7RPath@@6B@+00000044
00008: 0015 FF 15 00000000 CALL DWORD PTR __imp_??1BPath@@UAE@XZ
00009: 001B C7 43 20 00000008 MOV DWORD PTR 00000020[EBX], OFFSET ??_7RInterface@@6B@+00000008
00010: 0022             NOOP    
00011: 0022 8D 43 20    LEA     EAX, DWORD PTR 00000020[EBX]
00012: 0025 89 D8       MOV     EAX, EBX
00013: 0027     L0000
00014: 0027 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00015: 002A 5B          POP     EBX
00016: 002B 5D          POP     EBP
00017: 002C C3          RETN    

Function: ??1?$TRotateBuffer@PAVRBitmap@@@@UAE@XZ
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 89 CB       MOV     EBX, ECX
00007: 0007 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7?$TRotateBuffer@PAVRBitmap@@@@6B@+00000008
makeEmpty();
00009: 000D 83 7B 04 00 CMP     DWORD PTR 00000004[EBX], 00000000
00010: 0011 74 64       JE      L0001
00011: 0013 C7 43 04 00000000 MOV DWORD PTR 00000004[EBX], 00000000
00012: 001A C7 43 20 00000000 MOV DWORD PTR 00000020[EBX], 00000000
00013: 0021 8B 43 20    MOV     EAX, DWORD PTR 00000020[EBX]
00014: 0024 89 43 1C    MOV     DWORD PTR 0000001C[EBX], EAX
00015: 0027 EB 09       JMP     L0002
00016: 0029     L0003
00017: 0029 56          PUSH    ESI
00018: 002A E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00019: 002F 83 C4 04    ADD     ESP, 00000004
00020: 0032     L0002
00021: 0032 83 7B 18 00 CMP     DWORD PTR 00000018[EBX], 00000000
00022: 0036 74 06       JE      L0004
00023: 0038 83 7B 10 01 CMP     DWORD PTR 00000010[EBX], 00000001
00024: 003C 7D 04       JGE     L0005
00025: 003E     L0004
00026: 003E 31 F6       XOR     ESI, ESI
00027: 0040 EB 2F       JMP     L0006
00028: 0042     L0005
00029: 0042 FF 4B 10    DEC     DWORD PTR 00000010[EBX]
00030: 0045 8B 53 18    MOV     EDX, DWORD PTR 00000018[EBX]
00031: 0048 8B 43 10    MOV     EAX, DWORD PTR 00000010[EBX]
00033: 004B 83 7B 10 00 CMP     DWORD PTR 00000010[EBX], 00000000
00032: 004F 8B 34 82    MOV     ESI, DWORD PTR 00000000[EDX][EAX*4]
00034: 0052 75 1D       JNE     L0007
00035: 0054 09 D2       OR      EDX, EDX
00036: 0056 74 0C       JE      L0008
00037: 0058 8B 43 18    MOV     EAX, DWORD PTR 00000018[EBX]
00038: 005B 50          PUSH    EAX
00039: 005C E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00040: 0061 83 C4 04    ADD     ESP, 00000004
00041: 0064     L0008
00042: 0064 C7 43 14 00000000 MOV DWORD PTR 00000014[EBX], 00000000
00043: 006B 8B 43 14    MOV     EAX, DWORD PTR 00000014[EBX]
00044: 006E 89 43 10    MOV     DWORD PTR 00000010[EBX], EAX
00045: 0071     L0007
00046: 0071             NOOP    
00047: 0071     L0006
00048: 0071 89 F0       MOV     EAX, ESI
00049: 0073 09 F0       OR      EAX, ESI
00050: 0075 75 B2       JNE     L0003
00051: 0077     L0001
mNbBuffer = 0;
00053: 0077 C7 43 04 00000000 MOV DWORD PTR 00000004[EBX], 00000000
00054: 007E             NOOP    
00055: 007E 8D 43 24    LEA     EAX, DWORD PTR 00000024[EBX]
00056: 0081 89 C1       MOV     ECX, EAX
00057: 0083 E8 00000000 CALL    NEAR PTR ??1RSem@@UAE@XZ
00058: 0088 BE 00000008 MOV     ESI, OFFSET ??_7RInterface@@6B@+00000008
00059: 008D 89 73 30    MOV     DWORD PTR 00000030[EBX], ESI
00060: 0090             NOOP    
00061: 0090 8D 43 24    LEA     EAX, DWORD PTR 00000024[EBX]
00062: 0093 05 0000000C ADD     EAX, 0000000C
00063: 0098             NOOP    
00064: 0098 8D 43 24    LEA     EAX, DWORD PTR 00000024[EBX]
00065: 009B C7 43 08 00000008 MOV DWORD PTR 00000008[EBX], OFFSET ??_7?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@6B@+00000008
00066: 00A2 83 7B 18 00 CMP     DWORD PTR 00000018[EBX], 00000000
00067: 00A6 74 0C       JE      L0009
00068: 00A8 8B 43 18    MOV     EAX, DWORD PTR 00000018[EBX]
00069: 00AB 50          PUSH    EAX
00070: 00AC E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00071: 00B1 83 C4 04    ADD     ESP, 00000004
00072: 00B4     L0009
00073: 00B4 C7 43 14 00000000 MOV DWORD PTR 00000014[EBX], 00000000
00074: 00BB 8B 43 14    MOV     EAX, DWORD PTR 00000014[EBX]
00075: 00BE 89 43 10    MOV     DWORD PTR 00000010[EBX], EAX
00076: 00C1 89 73 08    MOV     DWORD PTR 00000008[EBX], ESI
00077: 00C4             NOOP    
00078: 00C4 8D 43 08    LEA     EAX, DWORD PTR 00000008[EBX]
00079: 00C7             NOOP    
00080: 00C7 8D 43 08    LEA     EAX, DWORD PTR 00000008[EBX]
00081: 00CA 89 33       MOV     DWORD PTR 00000000[EBX], ESI
00082: 00CC 89 D8       MOV     EAX, EBX
00083: 00CE     L0000
00084: 00CE 8D 65 F8    LEA     ESP, DWORD PTR FFFFFFF8[EBP]
00085: 00D1 5E          POP     ESI
00086: 00D2 5B          POP     EBX
00087: 00D3 5D          POP     EBP
00088: 00D4 C3          RETN    

Function: ?init@?$TRotateBuffer@PAVRBitmap@@@@IAEXJ@Z
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 56          PUSH    ESI
00006: 0005 57          PUSH    EDI
00007: 0006 83 EC 24    SUB     ESP, 00000024
00008: 0009 89 CB       MOV     EBX, ECX
mBufferList.makeEmpty();
00010: 000B 83 7B 18 00 CMP     DWORD PTR 00000018[EBX], 00000000
00011: 000F 74 0C       JE      L0001
00012: 0011 8B 43 18    MOV     EAX, DWORD PTR 00000018[EBX]
00013: 0014 50          PUSH    EAX
00014: 0015 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00015: 001A 83 C4 04    ADD     ESP, 00000004
00016: 001D     L0001
00017: 001D C7 43 14 00000000 MOV DWORD PTR 00000014[EBX], 00000000
00018: 0024 8B 43 14    MOV     EAX, DWORD PTR 00000014[EBX]
00019: 0027 89 43 10    MOV     DWORD PTR 00000010[EBX], EAX
mNbBuffer = nbitems;
00021: 002A 8B 45 08    MOV     EAX, DWORD PTR 00000008[EBP]
00022: 002D 89 43 04    MOV     DWORD PTR 00000004[EBX], EAX
mCurrentRead = mCurrentWrite = 0;
00024: 0030 C7 43 20 00000000 MOV DWORD PTR 00000020[EBX], 00000000
00025: 0037 8B 43 20    MOV     EAX, DWORD PTR 00000020[EBX]
00026: 003A 89 43 1C    MOV     DWORD PTR 0000001C[EBX], EAX
if (!mNbBuffer) return;
00028: 003D 8B 43 04    MOV     EAX, DWORD PTR 00000004[EBX]
00029: 0040 89 45 D4    MOV     DWORD PTR FFFFFFD4[EBP], EAX
00030: 0043 09 C0       OR      EAX, EAX
00031: 0045 75 08       JNE     L0002
return;
00033: 0047 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00034: 004A 5F          POP     EDI
00035: 004B 5E          POP     ESI
00036: 004C 5B          POP     EBX
00037: 004D 5D          POP     EBP
00038: 004E C3          RETN    
00039: 004F     L0002
for(n=mNbBuffer; n>0; n--)
00041: 004F             NOOP    
00042: 004F B8 00000008 MOV     EAX, OFFSET ??_7RErrEx@@6B@+00000008
00043: 0054 89 45 D0    MOV     DWORD PTR FFFFFFD0[EBP], EAX
00044: 0057 E9 0000010A JMP     L0003
00045: 005C     L0004
SRotateItem<PV> *item = new SRotateItem<PV>;
00047: 005C 6A 08       PUSH    00000008
00048: 005E E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00049: 0063 83 C4 04    ADD     ESP, 00000004
00050: 0066             NOOP    
00051: 0066             NOOP    
00052: 0066 89 C6       MOV     ESI, EAX
;
00054: 0068 09 F6       OR      ESI, ESI
00055: 006A 75 4B       JNE     L0005
00059: 006C 8D 45 E8    LEA     EAX, DWORD PTR FFFFFFE8[EBP]
00056: 006F 68 0000008C PUSH    0000008C
00057: 0074 68 00000000 PUSH    OFFSET .data+00000900
00058: 0079 68 00000000 PUSH    OFFSET .data+00000910
00060: 007E 89 C1       MOV     ECX, EAX
00061: 0080 E8 00000000 CALL    NEAR PTR ??0RErrEx@@QAE@PAD0J@Z
00062: 0085 83 C4 0C    ADD     ESP, 0000000C
00063: 0088 8B 45 D0    MOV     EAX, DWORD PTR FFFFFFD0[EBP]
00064: 008B 89 45 D8    MOV     DWORD PTR FFFFFFD8[EBP], EAX
00065: 008E 8B 45 EC    MOV     EAX, DWORD PTR FFFFFFEC[EBP]
00066: 0091 89 45 DC    MOV     DWORD PTR FFFFFFDC[EBP], EAX
00067: 0094 8B 45 F0    MOV     EAX, DWORD PTR FFFFFFF0[EBP]
00068: 0097 89 45 E0    MOV     DWORD PTR FFFFFFE0[EBP], EAX
00069: 009A BA 00000000 MOV     EDX, OFFSET .data+00000918
00071: 009F 8D 45 D8    LEA     EAX, DWORD PTR FFFFFFD8[EBP]
00070: 00A2 68 00000000 PUSH    OFFSET ??1RErrEx@@UAE@XZ
00072: 00A7 50          PUSH    EAX
00073: 00A8 52          PUSH    EDX
00074: 00A9 E8 00000000 CALL    NEAR PTR ___throw
00075: 00AE                    
00076: 00AE 83 C4 0C    ADD     ESP, 0000000C
00077: 00B1 8B 45 D0    MOV     EAX, DWORD PTR FFFFFFD0[EBP]
00078: 00B4 89 45 E8    MOV     DWORD PTR FFFFFFE8[EBP], EAX
00079: 00B7     L0005
item->mItem = NULL;
00081: 00B7 C7 06 00000000 MOV  DWORD PTR 00000000[ESI], 00000000
item->mState = kRotateFree;
00083: 00BD C7 46 04 00000000 MOV DWORD PTR 00000004[ESI], 00000000
if (!mBufferList.addItem(item)) M_THROW(kErrInit);
00085: 00C4 8B 53 10    MOV     EDX, DWORD PTR 00000010[EBX]
00086: 00C7 8B 43 14    MOV     EAX, DWORD PTR 00000014[EBX]
00087: 00CA 39 C2       CMP     EDX, EAX
00088: 00CC 7C 41       JL      L0006
00089: 00CE 8B 43 0C    MOV     EAX, DWORD PTR 0000000C[EBX]
00090: 00D1 01 43 14    ADD     DWORD PTR 00000014[EBX], EAX
00091: 00D4 8B 43 14    MOV     EAX, DWORD PTR 00000014[EBX]
00092: 00D7 C1 E0 02    SHL     EAX, 00000002
00093: 00DA 50          PUSH    EAX
00094: 00DB E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00095: 00E0 83 C4 04    ADD     ESP, 00000004
00096: 00E3             NOOP    
00097: 00E3             NOOP    
00098: 00E3 89 C7       MOV     EDI, EAX
00099: 00E5 09 FF       OR      EDI, EDI
00100: 00E7 75 04       JNE     L0007
00101: 00E9 31 C0       XOR     EAX, EAX
00102: 00EB EB 3A       JMP     L0008
00103: 00ED     L0007
00104: 00ED 31 D2       XOR     EDX, EDX
00105: 00EF EB 0A       JMP     L0009
00106: 00F1     L000A
00107: 00F1 8B 43 18    MOV     EAX, DWORD PTR 00000018[EBX]
00108: 00F4 8B 04 90    MOV     EAX, DWORD PTR 00000000[EAX][EDX*4]
00109: 00F7 89 04 97    MOV     DWORD PTR 00000000[EDI][EDX*4], EAX
00110: 00FA 42          INC     EDX
00111: 00FB     L0009
00112: 00FB 3B 53 10    CMP     EDX, DWORD PTR 00000010[EBX]
00113: 00FE 7C F1       JL      L000A
00114: 0100 8B 43 18    MOV     EAX, DWORD PTR 00000018[EBX]
00115: 0103 50          PUSH    EAX
00116: 0104 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00117: 0109 83 C4 04    ADD     ESP, 00000004
00118: 010C 89 7B 18    MOV     DWORD PTR 00000018[EBX], EDI
00119: 010F     L0006
00120: 010F 83 7B 18 00 CMP     DWORD PTR 00000018[EBX], 00000000
00121: 0113 75 04       JNE     L000B
00122: 0115 31 C0       XOR     EAX, EAX
00123: 0117 EB 0E       JMP     L0008
00124: 0119     L000B
00125: 0119 8B 53 10    MOV     EDX, DWORD PTR 00000010[EBX]
00126: 011C FF 43 10    INC     DWORD PTR 00000010[EBX]
00127: 011F 8B 43 18    MOV     EAX, DWORD PTR 00000018[EBX]
00128: 0122 89 34 90    MOV     DWORD PTR 00000000[EAX][EDX*4], ESI
00129: 0125 B0 01       MOV     AL, 00000001
00130: 0127     L0008
00131: 0127 08 C0       OR      AL, AL
00132: 0129 75 38       JNE     L000C
;
00134: 012B 6A 0C       PUSH    0000000C
00135: 012D E8 00000000 CALL    NEAR PTR ??2@YAPAXK@Z
00136: 0132 83 C4 04    ADD     ESP, 00000004
00137: 0135             NOOP    
00138: 0135             NOOP    
00139: 0135             NOOP    
00140: 0135 09 C0       OR      EAX, EAX
00141: 0137 74 13       JE      L000D
00142: 0139 8B 4D D0    MOV     ECX, DWORD PTR FFFFFFD0[EBP]
00143: 013C 89 08       MOV     DWORD PTR 00000000[EAX], ECX
00144: 013E C7 40 04 10000005 MOV DWORD PTR 00000004[EAX], 10000005
00145: 0145 C7 40 08 00000000 MOV DWORD PTR 00000008[EAX], OFFSET .data+00000924
00146: 014C     L000D
00147: 014C 89 45 E4    MOV     DWORD PTR FFFFFFE4[EBP], EAX
00148: 014F BA 00000000 MOV     EDX, OFFSET .data+00000930
00150: 0154 8D 45 E4    LEA     EAX, DWORD PTR FFFFFFE4[EBP]
00149: 0157 6A 00       PUSH    00000000
00151: 0159 50          PUSH    EAX
00152: 015A 52          PUSH    EDX
00153: 015B E8 00000000 CALL    NEAR PTR ___throw
00154: 0160 83 C4 0C    ADD     ESP, 0000000C
00155: 0163     L000C
}
00157: 0163 FF 4D D4    DEC     DWORD PTR FFFFFFD4[EBP]
00158: 0166     L0003
00159: 0166 83 7D D4 00 CMP     DWORD PTR FFFFFFD4[EBP], 00000000
00160: 016A 0F 8F FFFFFEEC JG   L0004
} // end of makeEmpty for TRotateBuffer< PV >
00162: 0170     L0000
00163: 0170 8D 65 F4    LEA     ESP, DWORD PTR FFFFFFF4[EBP]
00164: 0173 5F          POP     EDI
00165: 0174 5E          POP     ESI
00166: 0175 5B          POP     EBX
00167: 0176 5D          POP     EBP
00168: 0177 C3          RETN    

Function: ??_DRSem@@UAE@XZ
00001: 0000 55          PUSH    EBP
00002: 0001 89 E5       MOV     EBP, ESP
00003: 0003 53          PUSH    EBX
00004: 0004 89 CB       MOV     EBX, ECX
00005: 0006 E8 00000000 CALL    NEAR PTR ??1RSem@@UAE@XZ
00006: 000B C7 43 0C 00000008 MOV DWORD PTR 0000000C[EBX], OFFSET ??_7RInterface@@6B@+00000008
00007: 0012             NOOP    
00008: 0012 8D 43 0C    LEA     EAX, DWORD PTR 0000000C[EBX]
00009: 0015 89 D8       MOV     EAX, EBX
00010: 0017     L0000
00011: 0017 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00012: 001A 5B          POP     EBX
00013: 001B 5D          POP     EBP
00014: 001C C3          RETN    

Function: ??1?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@UAE@XZ
{
00002: 0000 55          PUSH    EBP
00003: 0001 89 E5       MOV     EBP, ESP
00004: 0003 53          PUSH    EBX
00005: 0004 89 CB       MOV     EBX, ECX
00006: 0006 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7?$TList@PAU?$SRotateItem@PAVRBitmap@@@@@@6B@+00000008
makeEmpty();
00008: 000C 8B 43 10    MOV     EAX, DWORD PTR 00000010[EBX]
00009: 000F 09 C0       OR      EAX, EAX
00010: 0011 74 09       JE      L0001
00011: 0013 50          PUSH    EAX
00012: 0014 E8 00000000 CALL    NEAR PTR ??3@YAXPAX@Z
00013: 0019 83 C4 04    ADD     ESP, 00000004
00014: 001C     L0001
00015: 001C C7 43 0C 00000000 MOV DWORD PTR 0000000C[EBX], 00000000
00016: 0023 8B 43 0C    MOV     EAX, DWORD PTR 0000000C[EBX]
00017: 0026 89 43 08    MOV     DWORD PTR 00000008[EBX], EAX
00018: 0029 C7 03 00000008 MOV  DWORD PTR 00000000[EBX], OFFSET ??_7RInterface@@6B@+00000008
00019: 002F 89 D8       MOV     EAX, EBX
00020: 0031     L0000
00021: 0031 8D 65 FC    LEA     ESP, DWORD PTR FFFFFFFC[EBP]
00022: 0034 5B          POP     EBX
00023: 0035 5D          POP     EBP
00024: 0036 C3          RETN    

Function: ??1CMoteurDocument@@UAE@XZ
{ mDocWindow = 0; mDocThread = 0; }
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
00005: 0005 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7CMoteurDocument@@6B@+00000008
00006: 000B 8B 42 04    MOV     EAX, DWORD PTR 00000004[EDX]
00007: 000E C7 00 00000014 MOV  DWORD PTR 00000000[EAX], OFFSET ??_7CMoteurDocument@@6B@+00000014
mDocWindow = 0; mDocThread = 0; }
00009: 0014 C7 42 08 00000000 MOV DWORD PTR 00000008[EDX], 00000000
mDocThread = 0; }
00011: 001B C7 42 0C 00000000 MOV DWORD PTR 0000000C[EDX], 00000000
00012: 0022 89 D0       MOV     EAX, EDX
00013: 0024     L0000
00014: 0024 C9          LEAVE   
00015: 0025 C3          RETN    

Function: ??1RInterface@@UAE@XZ
{ }
00002: 0000 55          PUSH    EBP
00004: 0001 89 CA       MOV     EDX, ECX
00003: 0003 89 E5       MOV     EBP, ESP
00005: 0005 C7 02 00000008 MOV  DWORD PTR 00000000[EDX], OFFSET ??_7RInterface@@6B@+00000008
00006: 000B 89 D0       MOV     EAX, EDX
00007: 000D     L0000
00008: 000D C9          LEAVE   
00009: 000E C3          RETN    

Function: @16@??_ECMoteurDocument@@UAE@I@Z
00000: 0000 83 C1 F0    ADD     ECX, FFFFFFF0
00000: 0003 E9 00000000 JMP     NEAR PTR ??_ECMoteurDocument@@UAE@I@Z

Function: @32@??_ERPath@@UAE@I@Z
00000: 0000 83 C1 E0    ADD     ECX, FFFFFFE0
00000: 0003 E9 00000000 JMP     NEAR PTR ??_ERPath@@UAE@I@Z

Function: @308@??_ECMoteurRecord@@UAE@I@Z
00000: 0000 81 C1 FFFFFECC ADD  ECX, FFFFFECC
00000: 0006 E9 00000000 JMP     NEAR PTR ??_ECMoteurRecord@@UAE@I@Z

Function: @64@??_ECMoteurRecord@@UAE@I@Z
00000: 0000 83 C1 C0    ADD     ECX, FFFFFFC0
00000: 0003 E9 00000000 JMP     NEAR PTR ??_ECMoteurRecord@@UAE@I@Z

Function: @24@??_ERRect@@UAE@I@Z
00000: 0000 83 C1 E8    ADD     ECX, FFFFFFE8
00000: 0003 E9 00000000 JMP     NEAR PTR ??_ERRect@@UAE@I@Z
Total cost of all spills: 1684

